<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 11~20]]></title>
    <url>%2FLeetCode-11-20%2F</url>
    <content type="text"><![CDATA[¶ 11 盛最多水的容器题目给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。**说明：**你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。示例:123&gt; 输入: [1,8,6,2,5,4,8,3,7]&gt; 输出: 49&gt;解题暴力法遍历每两个数据之间的面积时间复杂度： O(n2n^2n​2​​)12345678910111213class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int max_Area = 0; for (int i=0; i&lt;height.size()-1; i++) &#123; for (int j=i+1; j&lt;height.size(); j++) &#123; int area = (j-i)*min(height[i], height[j]); max_Area = max(area, max_Area); &#125; &#125; return max_Area; &#125;&#125;;双指针法面积最大，长与宽相应较大，从首尾开始，宽最大，根据长度逐步变化，计算最大面积时间复杂度： O(nnn)123456789101112class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int max_Area = 0, l=0, r=height.size()-1; while (l &lt; r) &#123; max_Area = max(max_Area, min(height[l], height[r])*(r-l)); if (height[l] &lt; height[r]) l ++; else r --; &#125; return max_Area; &#125;&#125;;¶ 12 整数转罗马数字题目罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。123456789&gt; 字符 数值&gt; I 1&gt; V 5&gt; X 10&gt; L 50&gt; C 100&gt; D 500&gt; M 1000&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。示例 1:123&gt; 输入: 3&gt; 输出: &quot;III&quot;&gt;示例 2:123&gt; 输入: 4&gt; 输出: &quot;IV&quot;&gt;示例 3:123&gt; 输入: 9&gt; 输出: &quot;IX&quot;&gt;示例 4:1234&gt; 输入: 58&gt; 输出: &quot;LVIII&quot;&gt; 解释: C = 100, L = 50, XXX = 30, III = 3.&gt;示例 5:1234&gt; 输入: 1994&gt; 输出: &quot;MCMXCIV&quot;&gt; 解释: M = 1000, CM = 900, XC = 90, IV = 4.&gt;解题暴力法对输入的数字，拆分为 千、百、十、个为分别判断是否为9、5、4，再计算需要输出多少个11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution &#123;public: string intToRoman(int num) &#123; string str = ""; int k = num/1000; // 千位 while (k --) &#123; str += 'M'; &#125; num %= 1000; int h = num/100; // 百位 if (h &gt;= 5) &#123; if (h == 9) &#123; str += "CM"; h -= 9; &#125; else &#123; str += 'D'; h -= 5; &#125; &#125; else if (h == 4) &#123; str += "CD"; h -= 4; &#125; while (h --) &#123; str += 'C'; &#125; num %= 100; int t = num/10; // 十位 if (t &gt;= 5) &#123; if (t == 9) &#123; str += "XC"; t -= 9; &#125; else &#123; str += 'L'; t -= 5; &#125; &#125; else if (t == 4) &#123; str += "XL"; t -= 4; &#125; while (t --) &#123; str += 'X'; &#125; num %= 10; // 个位 if (num &gt;= 5) &#123; if (num == 9) &#123; str += "IX"; num -= 9; &#125; else &#123; str += 'V'; num -= 5; &#125; &#125; else if (num == 4) &#123; str += "IV"; num -= 4; &#125; while (num --) &#123; str += 'I'; &#125; return str; &#125;&#125;;¶ 13 罗马数字转整数题目罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。123456789&gt; 字符 数值&gt; I 1&gt; V 5&gt; X 10&gt; L 50&gt; C 100&gt; D 500&gt; M 1000&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。示例 1:123&gt; 输入: &quot;III&quot;&gt; 输出: 3&gt;示例 2:123&gt; 输入: &quot;IV&quot;&gt; 输出: 4&gt;示例 3:123&gt; 输入: &quot;IX&quot;&gt; 输出: 9&gt;示例 4:1234&gt; 输入: &quot;LVIII&quot;&gt; 输出: 58&gt; 解释: L = 50, V= 5, III = 3.&gt;示例 5:1234&gt; 输入: &quot;MCMXCIV&quot;&gt; 输出: 1994&gt; 解释: M = 1000, CM = 900, XC = 90, IV = 4.&gt;解题上一题的逆过程，并不能难注意判断I、X、C出现的前一个字母即可12345678910111213141516171819202122232425class Solution &#123;public: int romanToInt(string s) &#123; int res = 0; for (int i=s.size()-1; i&gt;=0; i--) &#123; if (s[i] == 'I') &#123; if (i&lt;s.size() &amp;&amp; s[i+1] == 'V' || s[i+1] == 'X') res -= 1; else res += 1; &#125; else if (s[i] == 'V') res += 5; else if (s[i] == 'X') &#123; if (i&lt;s.size() &amp;&amp; s[i+1] == 'L' || s[i+1] == 'C') res -= 10; else res += 10; &#125; else if (s[i] == 'L') res += 50; else if (s[i] == 'C') &#123; if (i&lt;s.size() &amp;&amp; s[i+1] == 'D' || s[i+1] == 'M') res -= 100; else res += 100; &#125; else if (s[i] == 'D') res += 500; else if (s[i] == 'M') res += 1000; &#125; return res; &#125;&#125;;¶ 14 最长公共前缀题目编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。示例 1:123&gt; 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]&gt; 输出: &quot;fl&quot;&gt;示例 2:1234&gt; 输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]&gt; 输出: &quot;&quot;&gt; 解释: 输入不存在公共前缀。&gt;解题字符串数组为空，输出为 “”将第一个字符串与后面字符串对比，从第一个字母开始找到与后面字符串都不一样的字母位置1234567891011121314class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.empty()) return ""; for (int i=0; i&lt;strs[0].size(); i++) &#123; for(int j=1; j&lt;strs.size(); j++) &#123; if(strs[j][i]!=strs[0][i]) return strs[0].substr(0,i); &#125; &#125; return strs[0]; &#125;&#125;;¶ 15 三数之和题目给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 *a，b，c ，*使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。**注意：**答案中不可以包含重复的三元组。12345678&gt; 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，&gt; &gt; 满足要求的三元组集合为：&gt; [&gt; [-1, 0, 1],&gt; [-1, -1, 2]&gt; ]&gt;解题第一题“两数之和”的升级版，ps：不是输出坐标，而是相应值的三元组数组长度小于3，输出为{}为了防止出现重复的三元组，先对输入数组进行排序，再通过set添加，最后转化为vector暴力法：三次循环，时间复杂度：O(n3n^3n​3​​)，超时哈希：确定第一个值，作为target，对之前第一题做法进行改进时间复杂度：O(n2n^2n​2​​)，超时二分法：确定第一个值，对之后的值进行二分，从小到大，左值加右值，对比目标值target时间复杂度：O(nlognnlognnlogn)123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len &lt; 3) return &#123;&#125;; sort(nums.begin(), nums.end()); set&lt;vector&lt;int&gt;&gt; res; for (int i = 0; i &lt; len - 2; i ++) &#123; int l = i + 1, r = len - 1; while (l &lt; r) &#123; int value = nums[l] + nums[r]; if (value &lt; (-nums[i])) l ++; else if (value &gt; (-nums[i])) r --; else &#123; res.insert(&#123;nums[i], nums[l], nums[r]&#125;); while (l&lt;r &amp;&amp; nums[l] == nums[l+1]) l ++; while (l&lt;r &amp;&amp; nums[r] == nums[r-1]) r --; l ++; r --; &#125; &#125; &#125; return vector&lt;vector&lt;int&gt;&gt;(res.begin(), res.end()); &#125;&#125;;¶ 16 最接近的三数之和题目给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。1234&gt; 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.&gt; &gt; 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).&gt;解题最接近三数和，可能是大于target也可能是小于target，当然相等是最接近的接上一题，二分法先确定第一个数，更新target如果两数和小于新target，左边下标+1；如果两数和大于新target，右边下标-1；不断更新最接近三数和的值，和最小距离1234567891011121314151617181920212223242526272829class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); if (len &lt; 3) return &#123;&#125;; sort(nums.begin(), nums.end()); set&lt;vector&lt;int&gt;&gt; res; int dis = INT_MAX; int sum = 0; for (int i = 0; i &lt; len - 2; i ++) &#123; int new_target = target - nums[i]; int l = i + 1, r = len - 1; while (l &lt; r) &#123; int value = nums[l] + nums[r]; if (value &lt; new_target) l ++; else if (value &gt; new_target) r --; else return target; if (abs(new_target - value) &lt; dis) &#123; dis = abs(new_target - value); sum = nums[i] + value; &#125; &#125; &#125; return sum; &#125;&#125;;¶ 17 电话号码的字母组合题目给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。示例:123&gt; 输入：&quot;23&quot;&gt; 输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].&gt;解题每个数字包含3-4个字母，字母组合为$$(3 or 4)^n$$，数字字符串有多长就要多少个迭代器，所以只能通过递归来实现ps，下次遍历数字代表的字母，要把前一次字母踢掉12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; if (digits.empty()) return &#123;&#125;; vector&lt;string&gt; res; string item = ""; letterMix(res, digits, 0, item); return res; &#125;private: string str[10] = &#123;"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"&#125;; void letterMix(vector&lt;string&gt;&amp; res, string digits, int index, string&amp; item) &#123; if (index == digits.size()) &#123; res.push_back(item); return ; &#125; int num = digits[index] - '0'; for (int i=0; i&lt;str[num].size(); i++) &#123; item += str[num][i]; letterMix(res, digits, index+1, item); item.pop_back(); &#125; &#125;&#125;;¶ 18 四数之和题目给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意：答案中不可以包含重复的四元组。示例：123456789&gt; 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。&gt; &gt; 满足要求的四元组集合为：&gt; [&gt; [-1, 0, 0, 1],&gt; [-2, -1, 1, 2],&gt; [-2, 0, 0, 2]&gt; ]&gt;解题三数之和的进一步提升用之前二分法，多一个迭代器，时间复杂度：O(n^2 logn​)123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); if (len &lt; 4) return &#123;&#125;; sort(nums.begin(), nums.end()); set&lt;vector&lt;int&gt;&gt; res; for (int i = 0; i &lt; len - 3; i ++) &#123; for (int j = i + 1; j &lt; len -2; j++) &#123; int new_target = target - (nums[i] + nums[j]); int l = j + 1, r = len - 1; while (l &lt; r) &#123; int value = nums[l] + nums[r]; if (value &lt; new_target) l ++; else if (value &gt; new_target) r --; else &#123; res.insert(&#123;nums[i], nums[j], nums[l], nums[r]&#125;); while (l&lt;r &amp;&amp; nums[l] == nums[l+1]) l ++; while (l&lt;r &amp;&amp; nums[r] == nums[r-1]) r --; l ++; r --; &#125; &#125; &#125; &#125; return vector&lt;vector&lt;int&gt;&gt;(res.begin(), res.end()); &#125;&#125;;¶ 19 删除链表的倒数第N个节点题目给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。示例：1234&gt; 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.&gt; &gt; 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.&gt;解题第一步，将链表的值放到一个数组里第二步，将数组的值加到链表，出去v[v.size()-n]123456789101112131415161718class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* list = new ListNode(0), *tmp = head, *curr = list; vector&lt;int&gt; v; while (tmp) &#123; v.push_back(tmp-&gt;val); tmp = tmp-&gt;next; &#125; for (int i=0; i&lt;v.size(); i++) &#123; if (i == v.size()-n) continue; curr-&gt;next = new ListNode(v[i]); curr = curr-&gt;next; &#125; return list-&gt;next; &#125;&#125;;¶ 20 有效的括号题目给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。示例 1:123&gt; 输入: &quot;()&quot;&gt; 输出: true&gt;示例 2:123&gt; 输入: &quot;()[]&#123;&#125;&quot;&gt; 输出: true&gt;示例 3:123&gt; 输入: &quot;(]&quot;&gt; 输出: false&gt;示例 4:123&gt; 输入: &quot;([)]&quot;&gt; 输出: false&gt;示例 5:123&gt; 输入: &quot;&#123;[]&#125;&quot;&gt; 输出: true&gt;解题STL : &lt;stack&gt;发现一个左符号，就在栈中添加一个右符号stack先进后出找到一个右符号，出栈，比较12345678910111213141516171819class Solution &#123;public: bool isValid(string s) &#123; if (s.empty()) return true; stack&lt;int&gt; myStack; for (int i=0; i&lt;s.size(); i++) &#123; if (s[i] == '(') myStack.push(')'); else if (s[i] == '[') myStack.push(']'); else if (s[i] == '&#123;') myStack.push('&#125;'); else &#123; if (myStack.empty()) return false; if (myStack.top() != s[i]) return false; myStack.pop(); &#125; &#125; return myStack.empty(); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome扩展程序-书签及历史记录的搜索]]></title>
    <url>%2Fchrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F-%E4%B9%A6%E7%AD%BE%E5%8F%8A%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E7%9A%84%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[¶ 背景第一种情况：一般浏览习惯，会收藏一些页面，久而久之，收藏夹中存储过多，即使对页面进行分组也不好查找；chrome://bookmarks可以打开标签管理，但是跳转页面对用户始终是不友好的第二种情况：浏览器意外关闭，忘记保存页面，下次要找的时候就不太容易；同样chrome://historychrome浏览器支持自定义扩展，给开发者带来了更好的体验¶ chrome扩展程序详细教程一个扩展程序应包含文件：一个manifest.jsonhtml文件js文件icon图标¶ manifest.json包含一个扩展程序的注册信息1234567891011121314151617181920212223242526272829303132333435&#123; // 必须的字段 "name": "My Extension", "version": "versionString", "manifest_version": 2, // 建议提供的字段 "description": "A plain text description", "icons": &#123; ... &#125;, "default_locale": "en", // 多选一，或者都不提供 "browser_action": &#123;...&#125;, "page_action": &#123;...&#125;, "theme": &#123;...&#125;, "app": &#123;...&#125;, // 根据需要提供 "background": &#123;...&#125;, "chrome_url_overrides": &#123;...&#125;, "content_scripts": [...], "content_security_policy": "policyString", "file_browser_handlers": [...], "homepage_url": "http://path/to/homepage", "incognito": "spanning" or "split", "intents": &#123;...&#125; "key": "publicKey", "minimum_chrome_version": "versionString", "nacl_modules": [...], "offline_enabled": true, "omnibox": &#123; "keyword": "aString" &#125;, "options_page": "aFile.html", "permissions": [...], "plugins": [...], "requirements": &#123;...&#125;, "update_url": "http://path/to/updateInfo.xml", "web_accessible_resources": [...]&#125;browser actions 可以在chrome主工具条的地址栏右侧增加一个图标。作为这个图标的延展，一个browser action图标还可以有tooltip、badge和popup。12345678910&#123; "name": "My extension", ... "browser_action": &#123; "default_icon": "images/icon19.png", // optional "default_title": "Google Mail", // optional; shown in tooltip "default_popup": "popup.html" // optional &#125;, ...&#125;permissions 扩展程序将使用的一组权限。12345678"permissions": [ "tabs", "bookmarks", "http://www.blogger.com/", "http://*.google.com/", "unlimitedStorage" ],manifest_version 用整数表示manifest文件自身格式的版本号。content_security_policy 为缓解潜在的大规模的跨站点脚本攻击问题，Chrome扩展系统已遵循 Content Security Policy (CSP)的理念，引入了严格的策略使扩展更安全，同时提供创建和实施策略规则的能力，这些规则用以控制扩展（或应用）能够加载的资源和执行的脚本。定义manifest_version为2的扩展才会默认开启内容安全策略。1"content_security_policy": script-src 'self'; object-src 'self'放宽默认策略（白名单）12// 允许加载 https://example.com 上的脚本"content_security_policy": "script-src 'self' https://example.com; object-src 'self'"¶ searchAll查询 浏览器收藏夹 和 历史浏览记录效果如下：文件目录：manifest.json12345678910111213141516&#123; "manifest_version": 2, "content_security_policy": "script-src 'self' https://ajax.googleapis.com; object-src 'self'", "permissions": [ "bookmarks", // 访问 书签 权限 "history" // 访问 历史记录 权限 ], "browser_action": &#123; "default_title": "SearchAll", // brower_action 名称（鼠标悬停显示） "default_icon": "icon.png", // 任务栏 图标 "default_popup": "popup.html" // 弹框 样式 &#125;&#125;popup.html123456789101112131415161718&lt;html&gt;&lt;head&gt; &lt;script src="bookmarks.js"&gt;&lt;/script&gt; &lt;!--加载 bookmarks脚本--&gt; &lt;script src="history.js"&gt;&lt;/script&gt; &lt;!--加载 history脚本--&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;!--输入框--&gt; &lt;label for="search"&gt;Search:&amp;emsp;&lt;/label&gt;&lt;input id="search" autofocus="autofocus"&gt; &lt;/div&gt; &lt;div id="records"&gt; &lt;label for="bookmarks" id="label_marks"&gt;&lt;/label&gt; &lt;ul id="bookmarks"&gt;&lt;/ul&gt; &lt;!--标签列表--&gt; &lt;label for="history" id="label_history"&gt;&lt;/label&gt; &lt;ul id="history"&gt;&lt;/ul&gt; &lt;!--历史纪录列表--&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;bookmarks.js通过getTree方法可以获得用户完整的书签树。123chrome.bookmarks.getTree(function(bookmarkArray)&#123; //TODO: 对用户书签树进行处理，这里是将搜索到的每个连接加入到`id="bookmarks"`的&lt;ul&gt;中&#125;);点击链接，实现跳转这里使用到tabs标签，chrome标签模块被用于和浏览器的标签系统交互。create 和 update 不需要申请tabs权限12345678const li = $('&lt;li&gt;');const anchor = $('&lt;a&gt;');anchor.attr('href', bookmarkNode.url);anchor.text(bookmarkNode.title ? bookmarkNode.title : bookmarkNode.url);anchor.click(function () &#123; chrome.tabs.create(&#123;url: bookmarkNode.url&#125;);&#125;);li.append(anchor);history.js读取历史记录。Chrome提供了search和getVisits两种方法读取历史。通过search方法可以读取匹配指定文字，指定时间区间，指定条目的历史结果。12345678chrome.history.search(&#123; text: 'xxx', // 筛选文本 startTime: new Date().getTime()-24*3600*1000, endTime: new Date().getTime(), // 时间区间 maxResults: 20 // 筛选数目&#125;, function(historyItemArray)&#123; // TODO: 处理得到的历史纪律，同样添加到`id="history"`的&lt;ul&gt;中，并创建`tabs`标签，实现链接跳转&#125;);¶ 最后一步安装将本地文件加载到chrome浏览器，可以进行调试打包对本地文件进行封装，得到一个crx文件（扩展程序）和一个pem私钥文件（更新使用），得到crx文件，可以进行发布，提供给其他用户使用发布太贵了，开发者验证要$5.00，而且只能发布20个程序，而且不支持支付宝微信银联给个链接，自己看吧 —— 登录应用市场]]></content>
      <categories>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>js, extension</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1~10]]></title>
    <url>%2FLeetCode-1-10%2F</url>
    <content type="text"><![CDATA[¶ 1 两数之和题目给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。示例:12345&gt; 给定 nums = [2, 7, 11, 15], target = 9&gt; &gt; 因为 nums[0] + nums[1] = 2 + 7 = 9&gt; 所以返回 [0, 1]&gt;解题暴力循环遍历每个元素x， 再查找是否存在一个target-x的值时间复杂度：O(n2n^2n​2​​)空间复杂度：O(1)12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for (int i=0; i&lt;nums.size()-1; i++) &#123; int d = target - nums[i]; for (int j=i+1; j&lt;nums.size(); j++) &#123; if (d == nums[j]) &#123; vector&lt;int&gt; res = &#123;i, j&#125;;// res.push_back(i);// res.push_back(j); return res; &#125; &#125; &#125; &#125;&#125;;STL ：在进行迭代时，将值与坐标的映射关系存起来通过target-x差值去查找在映射表中的位置时间复杂度：O(n)空间复杂度：O(n)1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; m; for (int i=0; i&lt;nums.size(); i++) &#123; int d = target - nums[i]; cout &lt;&lt; m.count(d) &lt;&lt; endl; if (m.count(d) &gt; 0) &#123; return (vector&lt;int&gt;)&#123;m[d], i&#125;; &#125; else m[nums[i]] = i; &#125; &#125;&#125;;¶ 2 两数相加题目给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。示例：1234&gt; 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)&gt; 输出：7 -&gt; 0 -&gt; 8&gt; 原因：342 + 465 = 807&gt;解题考虑 链表为空的情况逐位相加，考虑进位 carry12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *l3 = new ListNode(0); ListNode *p = l1, *q = l2, *curr = l3; int carry = 0; while (p != NULL || q != NULL) &#123; int x = (p!=NULL) ? p-&gt;val : 0; int y = (q!=NULL) ? q-&gt;val : 0; int sum = x + y + carry; carry = sum/10; curr-&gt;next = new ListNode(sum%10); curr = curr-&gt;next; if (p != NULL) p = p-&gt;next; if (q != NULL) q = q-&gt;next; &#125; if (carry &gt; 0) &#123; curr-&gt;next = new ListNode(carry); &#125; return l3-&gt;next; &#125;&#125;;¶ 3 无重复字符的最长子串题目给定一个字符串，找出不含有重复字符的最长子串的长度。示例 1:1234&gt; 输入: &quot;abcabcbb&quot;&gt; 输出: 3 &gt; 解释: 无重复字符的最长子串是 &quot;abc&quot;，其长度为 3。&gt;示例 2:1234&gt; 输入: &quot;bbbbb&quot;&gt; 输出: 1&gt; 解释: 无重复字符的最长子串是 &quot;b&quot;，其长度为 1。&gt;示例 3:12345&gt; 输入: &quot;pwwkew&quot;&gt; 输出: 3&gt; 解释: 无重复字符的最长子串是 &quot;wke&quot;，其长度为 3。&gt; 请注意，答案必须是一个子串，&quot;pwke&quot; 是一个子序列 而不是子串。&gt;解题将第一个字符作为新的字符串遍历给定字符串，将不重复的字符添加进去，出现重复，从重复字符的下一个位置重新计算，比较子字符串大小123456789101112131415161718class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; string res = ""; int len = 0; if (! s.empty()) res += s[0]; for (int i=1; i&lt;s.size(); i++) &#123; int index = res.find(s[i]); if (index &gt; -1) &#123; if (res.size() &gt; len) len = res.size(); res = res.substr(index+1, s.size()); &#125; res += s[i]; &#125; if (res.size() &gt; len) len = res.size(); return len; &#125;&#125;;¶ 4 两个排序数组的中位数题目给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。你可以假设 nums1 和 nums2 不同时为空。示例 1:12345&gt; nums1 = [1, 3]&gt; nums2 = [2]&gt; &gt; 中位数是 2.0&gt;示例 2:12345&gt; nums1 = [1, 2]&gt; nums2 = [3, 4]&gt; &gt; 中位数是 (2 + 3)/2 = 2.5&gt;解题第一种情况：一个数组为空，只要找另一个数组的中位数即可，数组长度为偶数，位置在[len/2-1,len/2]之间；奇数，在len/2。第二种情况：两个数组都不为空将两个数组合并，合并过程计数，只要找到中间位置len/2即可123456789101112131415161718192021222324252627282930313233class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int len1 = nums1.size(); int len2 = nums2.size(); if (nums1.empty()) &#123; if (len2%2) return nums2[len2/2]; else return (nums2[len2/2-1]+nums2[len2/2])*1.0/2; &#125; else if (nums2.empty()) &#123; if (len1%2) return nums1[len1/2]; else return (nums1[len1/2-1]+nums1[len1/2])*1.0/2; &#125; else &#123; int i=0, j=0, cnt=0; int len = len1 + len2; vector&lt;int&gt; num; while (cnt &lt; len) &#123; if (i &lt; len1 &amp;&amp; nums1[i] &lt;= nums2[j] || j == len2) &#123; num.push_back(nums1[i++]); cnt ++; &#125; if (j &lt;len2 &amp;&amp; nums1[i] &gt; nums2[j] || i == len1) &#123; num.push_back(nums2[j++]); cnt ++; &#125; if (cnt &gt; len/2) &#123; if (len%2) return num[len/2]; else return (num[len/2-1]+num[len/2])*1.0/2; &#125; &#125; &#125; &#125;&#125;;¶ 5 最长回文子串题目给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。示例 1：1234&gt; 输入: &quot;babad&quot;&gt; 输出: &quot;bab&quot;&gt; 注意: &quot;aba&quot;也是一个有效答案。&gt;示例 2：123&gt; 输入: &quot;cbbd&quot;&gt; 输出: &quot;bb&quot;&gt;解题中心扩展法回文中心一共有2n-1个(回文长度为偶数情况，中心在两个数之间)奇数：expandAroundCenter(s, i, i);偶数：expandAroundCenter(s, i, i+1);计算最长回文的长度，更新最长回文的起点和终点，由此找到子字符串123456789101112131415161718192021222324252627class Solution &#123;public: string longestPalindrome(string s) &#123; if (s.empty()) return ""; int start = 0, end = 0; int len = 0; for (int i=0; i&lt;s.size(); i++) &#123; int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i+1); len = max(len1, len2); if (len &gt; end - start) &#123; start = i - (len-1)/2; end = i + len/2; &#125; &#125; return s.substr(start, end-start+1); &#125;private: int expandAroundCenter(string s, int left, int right) &#123; int L = left, R = right; while (L &gt;= 0 &amp;&amp; R &lt; s.size() &amp;&amp; s[L] == s[R]) &#123; L --; R ++; &#125; return R-L-1; &#125;&#125;;¶ 6 Z字形变换题目将字符串 &quot;PAYPALISHIRING&quot; 以Z字形排列成给定的行数：1234&gt; P A H N&gt; A P L S I I G&gt; Y I R&gt;之后从左往右，逐行读取字符：&quot;PAHNAPLSIIGYIR&quot;实现一个将字符串进行指定行数变换的函数:12&gt; string convert(string s, int numRows);&gt;示例 1:123&gt; 输入: s = &quot;PAYPALISHIRING&quot;, numRows = 3&gt; 输出: &quot;PAHNAPLSIIGYIR&quot;&gt;示例 2:123456789&gt; 输入: s = &quot;PAYPALISHIRING&quot;, numRows = 4&gt; 输出: &quot;PINALSIGYAHRPI&quot;&gt; 解释:&gt; &gt; P I N&gt; A L S I G&gt; Y A H R&gt; P I&gt;解题找规律第一种情况，一行，原序第二种情况，两行，交叉排序第三种情况，三行以上，可以发现总列数numColumns为⌈len/2⌉\lceil len/2\rceil⌈len/2⌉一列排满之后有numRows-2列只有单个字母，一共有 $$\lceil {len/(2numRows-2)} \rceil$$组1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: string convert(string s, int numRows) &#123; if (numRows == 1) return s; int len = s.size(); if (numRows == 2) &#123; string s1, s2; for (int i=0; i&lt;len; i++) &#123; if (i%2 == 0) s1 += s[i]; else s2 += s[i]; &#125; return s1+s2; &#125; string res; int numColumns = ceil(len*1.0/2); char z[numRows][numColumns]; for (int a=0; a&lt;numRows; a++) &#123; for (int b=0; b&lt;numColumns; b++) &#123; z[a][b] = ''; &#125; &#125; int cnt = ceil(len*1.0/(2*numRows-2)); int i = 0, c = 0; while (i &lt; len &amp;&amp; cnt --) &#123; int r = -1; for (int j=0; j&lt;numRows &amp;&amp; i&lt;len; i++, j++) &#123; z[++r][c] = s[i]; &#125; c ++; for (int k=0; k&lt;numRows-2 &amp;&amp; i&lt;len; i++, k++, c++) &#123; z[--r][c] = s[i]; &#125; &#125; for (int a=0; a&lt;numRows; a++) &#123; for (int b=0; b&lt;numColumns; b++) &#123; if (z[a][b] != '') res += z[a][b]; &#125; &#125; return res; &#125;&#125;;¶ 7 反转整数题目给定一个 32 位有符号整数，将整数中的数字进行反转。示例 1:123&gt; 输入: 123&gt; 输出: 321&gt;示例 2:123&gt; 输入: -123&gt; 输出: -321&gt;示例 3:123&gt; 输入: 120&gt; 输出: 21&gt;解题负数 false正数 反向最后判断 是否在INT范围123456789101112131415161718192021class Solution &#123;public: int reverse(int x) &#123; int flag = 1; if (x &lt; 0)&#123; flag = -1; x = -x; &#125; long y = x%10; x /= 10; while (x) &#123; y *= 10; y += x%10; x /= 10; &#125; y *= flag; if (y&lt;INT_MIN|| y&gt;INT_MAX) return 0; return y; &#125;&#125;;¶ 8 字符串转整数 (atoi)题目实现 atoi，将字符串转为整数。该函数首先根据需要丢弃任意多的空格字符，直到找到第一个非空格字符为止。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。若函数不能执行有效的转换，返回 0。说明：假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。如果数值超过可表示的范围，则返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。示例 1:123&gt; 输入: &quot;42&quot;&gt; 输出: 42&gt;示例 2:12345&gt; 输入: &quot; -42&quot;&gt; 输出: -42&gt; 解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。&gt; 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。&gt;示例 3:1234&gt; 输入: &quot;4193 with words&quot;&gt; 输出: 4193&gt; 解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。&gt;示例 4:12345&gt; 输入: &quot;words and 987&quot;&gt; 输出: 0&gt; 解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。&gt; 因此无法执行有效的转换。&gt;示例 5:12345&gt; 输入: &quot;-91283472332&quot;&gt; 输出: -2147483648&gt; 解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 &gt; 因此返回 INT_MIN (−231) 。&gt;解题第一步，去除多余空格第二步，判断结果为0的几种情况：首字符不是数字也不是+/-；首字符与相邻字符都部位数字第三步，记录+/-符号，找到连续数字字符串ps：上题判断int越界，long long可以搞定，这题给了一个更大的数，可以通过判断数字字符串的大小解决，注意前面连续多个0情况的干扰1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: int myAtoi(string str) &#123; string res; char tag = '+'; bool flag = false; int last = 0; for (int i=0; i&lt;str.size(); i++) &#123; if (str[i] == ' ') continue; if (!isNum(str[i]) &amp;&amp; str[i] != '+' &amp;&amp; str[i] != '-' || (i &lt;str.size()-1 &amp;&amp; !isNum(str[i]) &amp;&amp; !isNum(str[i+1]))) return 0; if (str[i] == '-' || str[i] == '+') tag = str[i]; while (i &lt; str.size() &amp;&amp; isNum(str[i])) &#123; res += str[i++]; flag = true; &#125; if (flag) break; &#125; return str2int(res, tag); &#125;private: bool isNum(char c) &#123; if (c &gt;= '0' &amp;&amp; c &lt;= '9') return true; return false; &#125; int str2int(string s, char tag) &#123; int i = 0; while (s[i] == '0') i ++; int len = s.size(); long long res = 0; if (len-i &gt; 10) &#123; if (tag == '-') return INT_MIN; else if (tag == '+') return INT_MAX; &#125; else &#123; for (; i&lt;len; i++) &#123; res *= 10; res += (s[i]-'0'); &#125; if (res &gt; INT_MAX) &#123; if (tag == '-') return INT_MIN; else if (tag == '+') return INT_MAX; &#125; else &#123; if (tag == '-') return -1*res; else if (tag == '+') return res; &#125; &#125; &#125;&#125;;¶ 9 回文数题目判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。示例 1:123&gt; 输入: 121&gt; 输出: true&gt;示例 2:1234&gt; 输入: -121&gt; 输出: false&gt; 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。&gt;示例 3:1234&gt; 输入: 10&gt; 输出: false&gt; 解释: 从右向左读, 为 01 。因此它不是一个回文数。&gt;解题与第7题类似负数 false正数 转化为字符串，判断12345678910111213141516171819202122232425class Solution &#123;public: bool isPalindrome(int x) &#123; if (x &lt; 0) return false; string str = int2str(x); cout &lt;&lt; "str " &lt;&lt; str &lt;&lt; endl; int len = str.size(); for (int i=0; i&lt;len/2; i++) &#123; if (str[i] != str[len-i-1]) return false; &#125; return true; &#125; private: string int2str(int x) &#123; string str; if (x &lt; 0) str += '-'; int y = abs(x); while (y) &#123; str += (y%10 +'0'); y /= 10; &#125; return str; &#125;&#125;;¶ 10 正则表达式匹配题目给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。123&gt; &apos;.&apos; 匹配任意单个字符。&gt; &apos;*&apos; 匹配零个或多个前面的元素。&gt;匹配应该覆盖整个字符串 (s) ，而不是部分字符串。说明:s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。示例 1:123456&gt; 输入:&gt; s = &quot;aa&quot;&gt; p = &quot;a&quot;&gt; 输出: false&gt; 解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。&gt;示例 2:123456&gt; 输入:&gt; s = &quot;aa&quot;&gt; p = &quot;a*&quot;&gt; 输出: true&gt; 解释: &apos;*&apos; 代表可匹配零个或多个前面的元素, 即可以匹配 &apos;a&apos; 。因此, 重复 &apos;a&apos; 一次, 字符串可变为 &quot;aa&quot;。&gt;示例 3:123456&gt; 输入:&gt; s = &quot;ab&quot;&gt; p = &quot;.*&quot;&gt; 输出: true&gt; 解释: &quot;.*&quot; 表示可匹配零个或多个(&apos;*&apos;)任意字符(&apos;.&apos;)。&gt;示例 4:123456&gt; 输入:&gt; s = &quot;aab&quot;&gt; p = &quot;c*a*b&quot;&gt; 输出: true&gt; 解释: &apos;c&apos; 可以不被重复, &apos;a&apos; 可以被重复一次。因此可以匹配字符串 &quot;aab&quot;。&gt;示例 5:12345&gt; 输入:&gt; s = &quot;mississippi&quot;&gt; p = &quot;mis*is*p*.&quot;&gt; 输出: false&gt;解题偷懒，直接regex详细请参考c++ 实现正则表达式匹配12345678class Solution &#123;public: bool isMatch(string s, string p) &#123; regex reg(p); bool res = regex_match(s, reg); return res; &#125;&#125;;¶ LeetCode]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL配置-Ubuntu]]></title>
    <url>%2FMySQL%E9%85%8D%E7%BD%AE-Ubuntu%2F</url>
    <content type="text"><![CDATA[¶ 安装服务端1$ sudo apt-get install mysql-server客户端1$ sudo apt-get install mysql-client检查是否安装成功1$ sudo netstat -tap | grep mysqlps : 安装过程可能会提示设置密码，按提示完成即可；若是没有提示，可以进行密码修改mySQL会自动生成一个用户debian-sys-maint12&gt; $ sudo vim /etc/mysql/debian.cnf&gt;打开用户配置文件，可以查看默认密码，通过登录该用户，来修改root用户的密码12345678910&gt; $ mysql -u debian-sys-maint -p&gt; # 输入默认秘密&gt; &gt; use mysql;&gt; &gt; update user set password=password('123456') where user='root';&gt; &gt; flush privileges;&gt; &gt; exit;&gt; # 登录验证&gt; $ mysql -u root -p&gt; # 输入密码 123456&gt;¶ 远程访问配置文件12$ sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf # 将bind-address = 127.0.0.1 注释授权方式一：改表123456789101112# `%`表示其他主机也能连接&gt; update user set host = '%' where user = 'root';&gt; flush privileges;&gt; select user, host from user;+------------------+-----------+| user | host |+------------------+-----------+| root | % || debian-sys-maint | localhost || mysql.session | localhost || mysql.sys | localhost |+------------------+-----------+方式二：授权12&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;&gt; flush privileges;重启服务1$ /etc/init.d/mysql restartps：如果其他主机还是连接不了mySQL，尝试修改mySQL的加密方式出现错误：ERROR 1698 (28000): Access denied for user ‘root’@‘ubuntu’详细请看：https://stackoverflow.com/questions/39281594/error-1698-28000-access-denied-for-user-rootlocalhost1234567891011121314&gt; mysql&gt; select user, plugin from user;&gt; +------------------+-----------------------+&gt; | user | plugin |&gt; +------------------+-----------------------+&gt; | root | auth_socket |&gt; | mysql.session | mysql_native_password |&gt; | mysql.sys | mysql_native_password |&gt; | debian-sys-maint | mysql_native_password |&gt; +------------------+-----------------------+&gt; 4 rows in set (0.00 sec)&gt; &gt; mysql&gt; update user set plugin='mysql_native_password' where user='root';&gt; mysql&gt; flush privileges;&gt;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 插件开发（二）Action解析]]></title>
    <url>%2FIntelliJ-IDEA-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89Action%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在plugin中，可以包含多个action，一个action代表一个活动，即一个功能项，比如主菜单栏（或其中子菜单）以及右键菜单中的一项。action继承类AnAction，主要重写的函数有两个，一个是actionPerformed，另一个是Update。¶ actionPerformed12345@Overridepublic void actionPerformed(AnActionEvent e)&#123; // TODO: insert action logic here&#125;每次点击一个action，即菜单项的时候，就会执行对应的actionPerformed函数上一篇博客，先创建一个Project对象，及获取IDEA当前项目（经过测试Windows貌似不用也可以弹出对话框，其他地方就不知道了），接着通过Messages.showMessageDialog来启动一个对话框。下一篇博客会讲到自定义对话框样式，原理都是一样的，还是要actionPerformed来获取对话框的一个对象显示出来。这里传入的参数是一个AnActionEvent对象，拉到最后有解释。¶ update12345@Overridepublic void update(AnActionEvent e)&#123; super.update(e);&#125;update函数在Action状态发生更新时被调用，当Action状态刷新，即点击主菜单显示action菜单项的时候，IDEA会回调update函数，并且传递AnActionEvent对象，AnActionEvent对象封装了当前action对应的环境。简单来说，就是，先执行update，在执行actionPerformed。想了解action生命周期的，可以通过日志的形式查看调用。下面讲解update的常用情景，当我们在特定环境才需要执行action时（例如指定文件类型），避免其他误操作，我们都会将action隐藏，这里的隐藏指定是最常见的不可操作，即灰处理enable(false) ，当然也可以是visible(false) 。123456789101112131415161718192021222324/* 指定扩展名 */private String[] extensions = &#123;"jar", "xml", "js", "html"&#125;;private String extension = "";@Overridepublic void update(AnActionEvent e)&#123; /* 读取文件扩展名 */ VirtualFile virtualFile = e.getData(DataKeys.VIRTUAL_FILE); if (virtualFile != null) extension = virtualFile.getExtension(); boolean flag = false; for (String name: extensions) &#123; // 判断 扩展名 if (name.equals(extension)) &#123; flag = true; break; &#125; &#125; // 设置 action 显隐 e.getPresentation().setEnabled(flag);&#125;¶ AnActionEvent可以发现，上面重载的两个函数，都传入了参数AnActionEvent对象。AnActionEvent 是我们与IntelliJ IDEA交互的桥梁，可以通过AnActionEvent对象来获取当前IntelliJ IDEA的各个模块对象，如项目窗口，编辑窗口等等，通过这些对象可以来做一些逻辑操作。¶ getData 函数传入DataKey&lt;T&gt; 或是 PlatformDataKey&lt;T&gt; 对象，它们已经与IntelliJ IDEA工具的对象做了映射。CommonDataKey.java12345public class CommonDataKeys &#123; public static final DataKey&lt;Project&gt; PROJECT = DataKey.create("project"); public static final DataKey&lt;Editor&gt; EDITOR = DataKey.create("editor"); ……&#125;PlatformDataKeys.java123public class PlatformDataKeys extends CommonDataKeys &#123; ……&#125;¶ getPresentation定义action的外观，文本、图标、是否显示等等1234567// gete.getPresentation().getText();e.getPresentation().getDescription();// sete.getPresentation().setText("action name");e.getPresentation().setIcon(AllIcons.Icon);e.getPresentation().setEnabled(false);¶ 参考链接IntelliJ Platform SDK DevGuide — ActionsAndroidStudio 插件开发（进阶篇之Action机制）]]></content>
      <categories>
        <category>IntelliJ IDEA</category>
      </categories>
      <tags>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 插件开发（一）Hello World]]></title>
    <url>%2FIntelliJ-IDEA-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89Hello-World%2F</url>
    <content type="text"><![CDATA[¶ 安装工具据说，IntelliJ IDEA 被认为是当前 Java 开发效率最快的 IDE 工具。个人感觉用起来也是比较顺手，JetBrains一系列工具的Alt+Enter快速修复功能，简直不要太好了，代码补全也是一级棒。这么好的工具不收费是不可能的，不过有社区版，一般开发者就凑合着用吧；不过JetBrains对学生党也是比较良心的，用教育邮箱注册可以享受一年免费使用权限。不废话，附上链接 IntelliJ IDEA顺便带上，快捷键使用链接Keymap¶ 新建项目目录结构¶ 第一个插件三行代码搞定一个“Hello World !”¶ 新建一个Action如下最初的样子¶ 进入正题三行代码1234567@Overridepublic void actionPerformed(AnActionEvent e)&#123; // TODO: insert action logic here Project project = e.getData(PlatformDataKeys.PROJECT); Messages.showMessageDialog(project, "Hello World!", "tips", Messages.getInformationIcon());&#125;第一句：获得一个Project对象第二句：弹出一个对话框（信息、标题、图标）最关键的一句在后面（其实如果前面创建action的时候，信息都填好了，可以跳过这一步）plugin.xml因为关键，所以重点分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;idea-plugin&gt; &lt;!-- id 一个插件的唯一标识，如果有多个插件在测试的时候，注意不要冲突了 name 插件的名称，安装插件后，可以在配置Settings&gt;Plugins中搜索 version 插件版本，开发迭代 vendor 提供商，可以填写自己的信息，方便使用者联系 description 插件描述，可以说明插件的功能之类 change-notes 更新的提示 idea-version IDEA兼容版本 since最早版本 last最新版本 --&gt; &lt;id&gt;com.your.company.unique.plugin.id&lt;/id&gt; &lt;name&gt;Plugin display name here&lt;/name&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;vendor email="support@yourcompany.com" url="http://www.yourcompany.com"&gt;YourCompany&lt;/vendor&gt; &lt;description&gt;&lt;![CDATA[ Enter short description for your plugin here.&lt;br&gt; &lt;em&gt;most HTML tags may be used&lt;/em&gt; ]]&gt;&lt;/description&gt; &lt;change-notes&gt;&lt;![CDATA[ Add change notes here.&lt;br&gt; &lt;em&gt;most HTML tags may be used&lt;/em&gt; ]]&gt; &lt;/change-notes&gt; &lt;idea-version since-build="173.0"/&gt; &lt;!--扩展 配置界面 &lt;aplicationConfigurable&gt; 属性id="xx"、instance(类)、displayname(显示名称)、groupid(位置，默认Other Settings)&gt; 子标签&lt;configurable&gt; 属性 id(可以设为xx.id，放置下级目录，也可以设置属性parentID="xx")--&gt; &lt;extensions defaultExtensionNs="com.intellij"&gt; &lt;!-- Add your extensions here --&gt; &lt;/extensions&gt; &lt;!--Action注册 &lt;action&gt; 属性id、类名class、显示text 子标签&lt;add-to-group&gt; 属性 group-id(菜单项) anchor(位置) relative-to-action(关联位置) 即action放在group-id里的relative-to-action的前/后 或者最前/后 子标签&lt;keyboard-shortcut&gt; 定义快捷键 --&gt; &lt;actions&gt; &lt;!-- Add your actions here 这里就是第三句了 --&gt; &lt;action id="com.example.test" class="HelloWorld" text="Hello World" &lt;add-to-group group-id="WindowMenu" anchor="first"/&gt; &lt;/action&gt; &lt;/actions&gt;&lt;/idea-plugin&gt;¶ 效果展示¶ 官网教程IntelliJ Platform SDK DevGuide]]></content>
      <categories>
        <category>IntelliJ IDEA</category>
      </categories>
      <tags>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ipv6_host]]></title>
    <url>%2Fipv6-host%2F</url>
    <content type="text"><![CDATA[¶ ipv6IPv6是Internet Protocol Version 6的缩写。IPv6是IETF（互联网工程任务组，Internet Engineering Task Force）设计的用于替代现行版本IP协议（IPv4）的下一代IP协议，号称可以为全世界的每一粒沙子编上一个网址。由于IPv4（32位）最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPv6（128位）的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍 。—— 百度百科¶ HostsHosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。 —— 百度百科位置Windows ：%SystemRoot\System32\Drivers\etc%（%SystemRoot%一般是 C:\Windows）Linux（Mac、Android）：/etc¶ 准备支持ipv6的网络（国内高校一般都有）最新的（具有ipv6地址与域名映射关系）hosts文件¶ 测试检查你的网络是否支持ipv6，test¶ 步骤更新host文件百度最新hosts文件，例如：老D博客Github地址，这里提供自动更新hosts文件的脚本1234567891011121314# update_hosts.pyusage: update_hosts [OPTIONS] FILEA simple multi-threading tool used for updating hosts file.Options: -h, --help show this help message and exit -s DNS set another dns server, default: 2001:4860:4860::8844 -o OUT_FILE output file, default: inputfilename.out -t QUERY_TYPE dig command query type, default: aaaa -c, --cname write canonical name into hosts file -n THREAD_NUM set the number of worker threads, default: 10 # merge_snippets.sh (shell下执行)usage: ./merge_snippets.sh new_hosts刷新DNS缓存Windows12# cmdipconfig /flushdnsLinux1sudo /etc/init.d/networking restart]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Android】Lab10_传感器应用及位置服务]]></title>
    <url>%2F%E3%80%90Android%E3%80%91Lab10-%E4%BC%A0%E6%84%9F%E5%99%A8%E5%BA%94%E7%94%A8%E5%8F%8A%E4%BD%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[The content is unfinished ! U2FsdGVkX1+YyH+9xHmjy+MzPsgRkNkD8R8hOYtiN2fsx90R5hLfGJAcrNuYSee82WA5kjUDiMIr04I9binIWLvf7IymQaRmmUmwmc4dK5WGI//av+igQdNsVXi8PYh0+M3f/J5pEjTRSu3dTd6rZ57527H9QBOJCNzlv5JsI6iKwT1eITc5jSOlvPhfKWjyOvCxBoTDQaQUJ4sTX+jXlMHFNxvQMxvMp65IzRKRZ28=]]></content>
  </entry>
  <entry>
    <title><![CDATA[【Android】Lab9_实现网络请求]]></title>
    <url>%2F%E3%80%90Android%E3%80%91Lab9-%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[¶ 一、实验题目Retrofit+RxJava+OkHttp 实现网络请求¶ 二、实验目的学习使用 Retrofit 实现网络请求学习 RxJava 中 Observable 的使用复习同步异步概念¶ 三、实现内容对于User Model, 显示 id, login, blog对于 Repository Model, 显示 name, description, language¶ 四、课堂实验结果1、实验截图从左至右， 依次为：启动界面、点击Fetch搜索、显示结果、 点击条目获取repositeries。从左至右， 依次为：repositories界面、搜索结果、长按删除、 搜索失败返回错误信息。2、实验步骤以及关键代码1）使用Retrofit实现网络请求第一步：定义Model类管理从网络获取的信息，包括用户信息(github.java)和用户库Repositories信息repos.javagithub:：login、id、blogrepos：name、language、description123456789public class Github &#123; private String login; private String blog; private String id; public String getLogin() &#123;return login;&#125; public String getBlog() &#123;return blog;&#125; public String getId() &#123;return id;&#125;&#125;123456789public class Repos &#123; private String name; private String description; private String language; public String getName() &#123;return name;&#125; public String getDescription() &#123;return description;&#125; public String getLanguage() &#123;return language;&#125;&#125;第二步：定义相应的访问接口注意是interface而不是class@GET(“路径”)表示get请求的接口，通过路径get到我们想要的数据。接口函数中通过参数@Path()中指定信息，动态修改接口路径，例如@Path(“user”) String user表示路径中的“user”替换为我们传入的参数，这样我们就可以访问具体用户信息。1234567public interface GithubService &#123; @GET("/users/&#123;user&#125;/repos") Observable&lt;List&lt;Repos&gt;&gt; getRepos(@Path("user") String user); @GET("/users/&#123;user&#125;") Observable&lt;Github&gt; getUser(@Path("user") String user);&#125;第三步：创建Retrofit创建OkHttp：OkHttp负责发起网络请求、维护网络连接以及处理访问超时等操作。创建Retrofit：Retrofit会创建一个OkHttp来访问网络，而且还将网络传输的数据转换为我们可用的model对象。从API获取到的是一个JSON格式的数据，可以通过GsonConverter来转换，所以在创建Retrofit的时候调用addConverterFactory(GsonConverterFactory.create())。调用addCallAdapterFactory(RxJavaCallAdapterFactory.create())可以将返回的数据转换成RxJava的Observable对象，进行异步操作。12345678910111213141516171819202122public class ServiceFactory &#123; private static OkHttpClient createOkHttp() &#123; return new OkHttpClient.Builder() .connectTimeout(10, TimeUnit.SECONDS) // 连接超时 .readTimeout(30, TimeUnit.SECONDS) // 读超时 .writeTimeout(10, TimeUnit.SECONDS) // 写超时 .build(); &#125; private static Retrofit createRetrofit(String baseUrl) &#123; return new Retrofit.Builder() .baseUrl(baseUrl) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .client(createOkHttp()) .build(); &#125; public static Retrofit getRetrofit(String url) &#123; return createRetrofit(url); &#125;&#125;第四步：构造Retrofit对象并且设置相应的URL，获取并处理数据因为网络操作方式一般比较耗时，如果在主线程直接同步访问的话，肯能会造成UI线程阻塞，并且抛出异常。所以我们需要采取异步操作的方式访问网络，这里使用的是RxJava。RxJava的异步实现是通过一种扩展的观察者模式（Observable）来实现的。subscribeOn：定义一个线程来执行耗时操作并反馈信息；observeOn：定义一个线程来监听和检查Observable最新发出的消息；• Schedulers.immediate()：直接在当前线程运行，这是默认的 Scheduler。• Schedulers.newThread()：启用新线程，并在新线程执行操作。• Schedulers.io()：I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。• Schedulers.computation()：计算所使用的 Scheduler。• AndroidSchedulers.mainThread()：指定的操作在主线程运行。subscribe：订阅观察者（Observable），需要实现三个方法onCompleted：事件队列结束，不会再有新的onNext发出；onError：事件队列异常，自动终止，不再有事件发出；onNext：事件传递，可以更新UI线程。本次有两处需要访问网络，异步更新UI线程。MainActivity里面，点击Fetch按钮触发，访问github用户信息1234567891011121314151617181920212223242526GithubService service = ServiceFactory.getRetrofit("https://api.github.com/") .create(GithubService.class);service.getUser(search.getText().toString()) .subscribeOn (Schedulers.io()) // 启用io线程进行网络访问 .observeOn(AndroidSchedulers.mainThread()) // 在主线程处理请求结果 .subscribe(new Subscriber&lt;Github&gt;() &#123; // 订阅观察者 @Override public void onCompleted() &#123; // 完成数据传输 progress.setVisibility(View.INVISIBLE);// 进度条隐藏 Log.d("TAG", "Search Successfully"); &#125; @Override public void onError(Throwable e) &#123; // 网络异常 progress.setVisibility(View.INVISIBLE);// 进度条隐藏 Toast.makeText(MainActivity.this, e.hashCode() + "请确认你搜索的用户存在", Toast.LENGTH_SHORT).show(); Log.d("TAG", "Fail to search the User"); &#125; @Override public void onNext(Github item) &#123; // 传递数据，更新UI list.add(item); cards.notifyDataSetChanged(); Log.d("TAG", "Add Successfully"); &#125; &#125;);另一处，点击用户，跳转到ReposActivity，访问用户的Repositories1234567891011121314151617181920212223242526272829303132333435GithubService service = ServiceFactory.getRetrofit("https://api.github.com/") .create(GithubService.class);service.getRepos(name) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Repos&gt;&gt;() &#123; @Override public void onCompleted() &#123; progressBar.setVisibility(View.INVISIBLE);// 进度条隐藏 Log.d("TAG", "Get Repositories Successfully"); &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(ReposActivity.this, "Fail to get repositories", Toast.LENGTH_SHORT).show(); // 返回错误信息 Log.d("TAG", "Fail to get repositories"); progressBar.setVisibility(View.INVISIBLE);// 进度条隐藏 &#125; @Override public void onNext(List&lt;Repos&gt; list) &#123; for (Repos item : list) &#123; Map&lt;String, Object&gt; temp = new LinkedHashMap&lt;&gt;(); temp.put("name", item.getName()); temp.put("language", item.getLanguage()); temp.put("description", item.getDescription()); reposList.add(temp); &#125; // 将每条repos写到list容器里 sa = new SimpleAdapter(ReposActivity.this, reposList, R.layout.repos_item, // 设置适配器，用list填充view new String[]&#123;"name", "language", "description"&#125;, new int[]&#123;R.id.name, R.id.language, R.id.descriptionn&#125;); reposListView = (ListView)findViewById(R.id.repos_list); reposListView.setAdapter(sa); Log.d("TAG", "Show Successfully"); &#125;&#125;);2） RecyclerView的设置在RecylerView中必须自定义实现适配器RecyclerView.Adapter并为其提供数据集合，实现时必须遵循ViewHolder的设计模式。ViewHolder使得RecylerView滚动的时候能快速设置值，而不必每次都重新创建很多对象，从而提升性能。第一步：自定义ViewHolder12345678910111213141516171819202122232425262728public class ViewHolder extends RecyclerView.ViewHolder &#123; private SparseArray&lt;View&gt; mViews; // 存储listItem的子view private View mConvertView; // 存储listItem private Context mContext; public ViewHolder(Context context, View itemView, ViewGroup parent) &#123; super(itemView); mConvertView = itemView; mViews = new SparseArray&lt;&gt;(); mContext = context; &#125; //获取viewHolder实例（item视图） public static ViewHolder get(Context context, ViewGroup parent, int itemId) &#123; View view = LayoutInflater.from(context).inflate(itemId, parent, false); //加载布局 ViewHolder holder = new ViewHolder(context, view, parent); return holder; &#125; public &lt;T extends View&gt; T getView(int viewId) &#123; View view = mViews.get(viewId); if (view == null) &#123; view = mConvertView.findViewById(viewId); // 创建子view mViews.put(viewId, view); // 将view存入mViews &#125; return (T) view; &#125;&#125;第二步：自定义Adapter12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public abstract class CardAdapter extends RecyclerView.Adapter&lt;ViewHolder&gt; &#123; private Context mContext; private int mlayoutId; private List&lt;Github&gt; mDatas; private LayoutInflater mInflater; private OnItemClickListener mOnItemClickListener; public CardAdapter(Context context, int layout, List&lt;Github&gt; datas) &#123; mContext = context; mlayoutId = layout; mDatas = datas; mInflater = LayoutInflater.from(context); &#125; @Override // 根据item_layout创建Viewholder public ViewHolder onCreateViewHolder(final ViewGroup parent, int viewType) &#123; ViewHolder viewHolder = ViewHolder.get(mContext, parent, mlayoutId); return viewHolder; &#125; @Override // 绑定数据 public void onBindViewHolder(final ViewHolder holder, int position) &#123; convert(holder, mDatas.get(position)); if(mOnItemClickListener != null)&#123; holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override // 单击 public void onClick(View view) &#123; mOnItemClickListener.onClick(holder.getAdapterPosition()); &#125; &#125;); // 长按 holder.itemView.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View view) &#123; mOnItemClickListener.onLongClick(holder.getAdapterPosition()); return true; &#125; &#125;); &#125; &#125; // 绑定数据到item视图上 protected abstract void convert(ViewHolder holder, Github item); @Override public int getItemCount() &#123; return mDatas.size(); &#125; // 监听器 public void setOnItemClickListener(OnItemClickListener onItemClickListener) &#123; mOnItemClickListener = onItemClickListener; &#125; public static abstract interface OnItemClickListener &#123; // 点击/长按的抽象函数 public abstract void onClick(int paramInt); public abstract void onLongClick(int paramInt); &#125;&#125;第三步：RecyclerView的使用1234567891011121314151617// 实例化一个RecyclerView对象RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);// 设置布局管理器recyclerView.setLayoutManager(new LinearLayoutManager(this));// 定义适配器cards = new CardAdapter(this, R.layout.recyle_view_item, list) &#123; @Override protected void convert(ViewHolder holder, Github item) &#123; TextView login = holder.getView(R.id.login); login.setText(item.getLogin()); TextView id = holder.getView(R.id.id); id.setText(String.format("id: %s", item.getId())); TextView blog = holder.getView(R.id.blog); blog.setText(String.format("blog: %s", item.getBlog())); &#125;&#125;; // 启动适配器recyclerView.setAdapter(cards);3）去标题栏，并且使主题颜色与按钮颜色一致AS创建一个新项目的时候，默认的主题是android:theme=&quot;@style/Apptheme&quot;具体定义在style.xml内123456&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt;colorPrimary：应用的主色调，actionBar默认使用该颜色，导航栏的底色；colorPrimaryDark：应用的主要暗色调，statusBar默认使用该颜色；colorAccent：CheckBox，RadioButton，SwitchCompat等一般控件的选中效果默认采用该颜色。去掉标题栏，将parent设置为Theme.AppCompat.Light.NoActionBar就可以了主题颜色一致，可以将所有颜色都设置与按钮颜色一致。3、实验遇到困难以及解决思路启动界面，一直搜索失败？查看是否有获取网络访问的权限12&lt;uses-permission android:name="android.permission.INTERNET"/&gt;&lt;uses-permission android:name="android.permission.CHANGE_NETWORK_STATE"/&gt;RxJava的对象Observable不能调用方法subscribeOn()?原因：在定义接口类的时候，getUser返回的是一个Observable对象，库包含引用了错误的库import android.database.Observable，该库中的Observable对象没有方法subscribeOn()。解决：正确的库import rx.ObservablerecycleView中的条目发生重叠？检查发现，长按删除是可以显示下一个条目的，所以说，list是有怎加item的。最后发现是布局recycle_view_item.xml设置错误，新建布局的时候没有修改高度，默认是match_parent，即填充整个布局，所以会发生条目覆盖，应该设置为wrap_content。repos界面每一项都是进度圈？ReposActivity在获取事件返回值直接调用getIntent().getExtra().toString()，没有获取根据key“user”来取值，所以跳转页面时错误。修改getIntent().getStringExtra(&quot;user&quot;)¶ 五、课后实验结果截图点击repository项目可以跳转到从左往右，依次为：repos界面、点击一个条目访问网页、点击网页内链接跳转到另一个页面重开一个Activity来实现跳转比较麻烦，直接在repos中设置一个WebView123456&lt;WebView android:layout_width="match_parent" android:layout_height="match_parent" android:id="@+id/web" android:visibility="gone"&gt; // 刚开始先隐藏起来&lt;/WebView&gt;1234567891011121314151617181920212223242526272829wv = (WebView)findViewById(R.id.web);wv.setWebViewClient(new WebViewClient()&#123; public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; view.loadUrl(url); // 当打开的网页中包含链接的时候，点击可以跳转 return true; &#125;&#125;);// 设置监听器reposListView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; String uri = "https://github.com/"+name+"/"+reposList.get(position).get("name"); wv.setVisibility(View.VISIBLE); // 点击条目显示WebView wv.loadUrl(uri); &#125;&#125;);// 重载返回按键@Overridepublic void onBackPressed() &#123; if(wv.canGoBack()) &#123; wv.goBack(); // 返回前一个页面 Log.d("TAG", "WebView"); &#125;else if (wv.getVisibility() == View.VISIBLE) &#123; wv.setVisibility(View.INVISIBLE); // 返回到repos界面 Log.d("TAG", "Repos"); &#125; else super.onBackPressed();&#125;Github]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Android】Lab8_数据存储（二）]]></title>
    <url>%2F%E3%80%90Android%E3%80%91Lab8-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[¶ 一、实验题目数据存储（二）¶ 二、实验目的学习 SQL 数据库的使用学习 ContentProvider 的使用复习 Android 界面编程¶ 三、实现内容实现一个生日备忘录， 要求实现：使用 SQLite 数据库保存生日的相关信息，并使得每一次运行程序都可以显示出已经存储在数据库里的内容；使用 ContentProvider 来获取手机通讯录中的电话号码。功能要求：A. 主界面包含增加生日条目按钮和生日信息列表；B. 点击“增加条目” 按钮，跳转到下一个 Activity 界面， 界面中包含三个信息输入框（姓名、生日、礼物） 和一个“增加” 按钮， 姓名字段不能为空且不能重复；C. 在跳转到的界面中，输入生日的相关信息后， 点击“增加” 按钮返回到主界面， 此时，主界面中应更新列表，增加相应的生日信息；D. 主界面列表点击事件：点击条目：弹出对话框，对话框中显示该条目的信息，并允许修改；对话框下方显示该寿星电话号码（如果手机通讯录中有的话，如果没有就显示“无” ）点击“保存修改” 按钮， 更新主界面生日信息列表。长按条目：弹出对话框显示是否删除条目；点击“是” 按钮，删除该条目，并更新主界面生日列表。¶ 四、课堂实验结果1、实验截图从左至右， 依次为：获取权限、初始界面、添加一部分条目、 添加页面。从左至右，依次为：名字不能为空、名字不能重复、点击显示条目信息（可修改）、长按删除。2、实验步骤以及关键代码1） 使用SQLite数据库第一步：创建实体类Member方便管理数据库中的各种数据元素：属性、构造函数、get函数、set函数12345678910111213141516171819202122public class Member &#123; private Integer id; private String name; private String birth; private String gift; public Member(String name, String birth, String gift) &#123; this.name = name; this.birth = birth; this.gift = gift; &#125; public Integer getId() &#123;return id;&#125; public String getName() &#123; return name;&#125; public String getBirth() &#123;return birth;&#125; public String getGift() &#123; return gift;&#125; public void setId(Integer id) &#123;this.id = id;&#125; public void setName(String name) &#123;this.name = name;&#125; public void setBirth(String birth) &#123;this.birth = birth;&#125; public void setGift(String gift) &#123;this.gift = gift; &#125;&#125;第二步：使用应用程序上下文创建SQLite数据库通过调用SQLiteDatabase类的公共函数insert()、 delete()、 query()和update()，实现增、删、查、改；每项操作之前必须先打开数据库getWirtableDatabase()或getReadableDatabase()使用容器 ContentValues 存储一个元组，再进行插入和更新更新、删除、查找调用的方法需要传入两个whereClause和whereClaus找到指定位置（约束条件）查找的方法query()较为复杂，返回的是一个Cursor对象，查询结果一般不止一个元组，所以可以通过Cursor类的方法来获取信息，常用的有moveToNext：将指针移动到下一条数据上getCount：获取集合的数据数量getCloumnIndex：根据属性名称返回序号1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class MyDB extends SQLiteOpenHelper &#123; private static final String DB_NAME = "Contacts.db"; // 数据库名字 private static final String TABLE_NAME = "Contacts"; // TABLE名字 private static final int DB_VERSION = 1; // 版本号 public MyDB(Context context) &#123; // 构造函数，方便创建，只传入context super(context, DB_NAME, null, DB_VERSION); &#125; /* * 执行execSQL，新建TABLE * 第一次调用getWirtableDatabase()或getReadableDatabase()的时候调用 */ @Override public void onCreate(SQLiteDatabase db) &#123; String CREATE_TABLE = "create table " + TABLE_NAME + "(_id integer primary key, " + "name text not null, " + "birth text, " + "gift text);"; db.execSQL(CREATE_TABLE); &#125; /* * 防止数据库冲突 * 创建TABLE的时候会先将数据库中同名的TABLE删除 */ @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL("drop table if exists " + TABLE_NAME); onCreate(db); &#125; //增 public void insert(Member item) &#123; SQLiteDatabase db = getWritableDatabase(); ContentValues values = new ContentValues(); values.put("name", item.getName()); values.put("birth", item.getBirth()); values.put("gift", item.getGift()); db.insert(TABLE_NAME, null, values); Log.d("TAG", "Add Successfully"); &#125; //删 public void delete(String name) &#123; SQLiteDatabase db = getWritableDatabase(); String whereClause = "name = ?"; String[] whereArgs = &#123;name&#125;; db.delete(TABLE_NAME, whereClause, whereArgs); Log.d("TAG", "Delete Successfully"); &#125; //查 public Cursor query(String info, String arg) &#123; SQLiteDatabase db = getReadableDatabase(); String selection; String[] selectionArgs; if(info == null)&#123; selection = null; selectionArgs = null; &#125;else &#123; selection = info + " = ? "; selectionArgs = new String[]&#123;arg&#125;; &#125; Cursor c = db.query(TABLE_NAME, null, selection, selectionArgs, null, null, null); Log.d("TAG", "Query Successfully"); return c; &#125; //改 public void update(Member item) &#123; SQLiteDatabase db = getWritableDatabase(); ContentValues values = new ContentValues(); String whereClause = "name = ?"; String[] whereArgs = &#123;item.getName()&#125;; values.put("name", item.getName()); values.put("birth", item.getBirth()); values.put("gift", item.getGift()); db.update(TABLE_NAME, values, whereClause, whereArgs); Log.d("TAG", "Update Successfully"); &#125;&#125;2） 添加新联系人活动（AddItem.java）的设置为保存信息的按钮设置监听器getText()读取填写的信息调用数据库，传入填写的名字作为查询信息，数据库语句“Select * from TABLE_NAME where name = ‘名字’”，返回Cusor对象，同过getCount()获取查询到的数据数量。等于0表示没有重复，就可以执行insert()，最后finish()结束活动，跳转到主页面。12345678910111213141516171819202122Button ok = (Button) findViewById(R.id.ok);ok.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String str1 = name.getText().toString(); String str2 = birth.getText().toString(); String str3 = gift.getText().toString(); Member item = new Member(str1, str2, str3); if(str1.isEmpty()) &#123; Toast.makeText(AddItem.this, "名字为空，请完善", Toast.LENGTH_SHORT).show(); return; &#125; Cursor c = db.query("name", str1); if(c.getCount() &gt; 0) &#123; Toast.makeText(AddItem.this.getApplicationContext(), "名字重复啦，请检查", Toast.LENGTH_SHORT).show(); &#125;else &#123; db.insert(item); finish(); &#125; &#125;&#125;);3）主界面（MainActivity.java）的设置第一步：初始化列表实例化数据库MyDB的一个对象db，通过查询显示数据库中所有信息（参数都为null），返回一个Corsor对象，接着将数据先添加到List&lt;Map&lt;&gt;&gt;列表，最后通过适配器SimpleAdapter为布局列表和数据列表建立起关系。1234567891011121314151617public void ShowList() &#123; list.clear(); Cursor c = db.query(null, null); while (c.moveToNext()) &#123; Map&lt;String, Object&gt; temp = new LinkedHashMap&lt;&gt;(); temp.put("name", c.getString(c.getColumnIndex("name"))); temp.put("birth", c.getString(c.getColumnIndex("birth"))); temp.put("gift", c.getString(c.getColumnIndex("gift"))); list.add(temp); &#125; listView = (ListView)findViewById(R.id.list); sa = new SimpleAdapter(MainActivity.this, list, R.layout.item, new String[]&#123;"name", "birth", "gift"&#125;, new int[]&#123;R.id.name, R.id.birth, R.id.gift&#125;); listView.setAdapter(sa); c.close(); Log.d("TAG", "ShowList Successfully");&#125;第二步：点击“增加条目”按钮跳转事件处理，setclass绑定跳转的活动from，to，startActivity启动新活动。123456789add.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d("TAG","AddItem"); Intent intent = new Intent(); intent.setClass(MainActivity.this, AddItem.class); startActivity(intent); &#125;&#125;);第三步：单击显示对话框，对话框信息包括不仅包括数据库对应数据还包括电话，可修改。查询通讯录获取权限，AndroidManifest .xml&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt;通讯录APIContactsContract.Contacts.CONTENT_URI 来获取联系人的ID和NAMEContactsContract.CommonDataKinds.Phone.CONTENT_URI 获取联系人的电话号码ContactsContract.CommonDataKinds.Email.CONTENT_URI 获取联系人的邮箱地址根据名字查找电话号码：一般通过ContactsContract.Contacts.CONTENT_URI 读取所有联系人，再moveToNext遍历（读id，找name，对比），找到对应的联系人，再根据id通过ContactsContract.CommonDataKinds.Phone.CONTENT_URI找到电话号码。下面尝试的是直接通过名字查找电话号码，显示结果正确123456789101112131415String selection = "display_name = ?";String[] selectionArgs = &#123; name &#125;;Cursor cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, selection, selectionArgs, null);if(cursor!=null &amp;&amp; cursor.getCount()&gt;=0) &#123; while (cursor.moveToNext()) &#123; int isHas = Integer.parseInt(cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts. HAS_PHONE_NUMBER))); if (isHas &gt; 0) &#123; String phoneNumber = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); getPhone.setText(phoneNumber); &#125; &#125; cursor.close();&#125;else &#123; getPhone.setText("无");&#125;自定义对话框布局layout_dialog.xml，通过LayoutInflater的方法inflate实例化一个View对象，再通过setView加载布局123View dialogView = LayoutInflater.from(MainActivity.this).inflate(R.layout.layout_dialog, null);AlertDialog.Builder b1 = new AlertDialog.Builder(MainActivity.this) .setView(dialogView);单击显示信息，可以修改1234567891011121314151617b1.setNegativeButton("放弃修改", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(MainActivity.this, "修改已放弃", Toast.LENGTH_SHORT).show(); &#125;&#125;).setPositiveButton("保存修改", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; birth = getBirth.getText().toString(); gift = getGift.getText().toString(); Member item = new Member(name, birth, gift); db.update(item); // 更新数据库 list.get(position).put("birth", birth); // 更新list list.get(position).put("gift", gift); sa.notifyDataSetChanged(); // 更新布局 &#125;&#125;).create().show();长按询问是否删除123456789101112131415161718192021listView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() &#123; @Override public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, final int position, long id) &#123; AlertDialog.Builder b2 = new AlertDialog.Builder(MainActivity.this); b2.setMessage("是否删除？"); b2.setNegativeButton("否", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(MainActivity.this, "不删除联系人", Toast.LENGTH_SHORT).show(); &#125; &#125;).setPositiveButton("是", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; db.delete(list.get(position).get("name").toString());//数据库操作 list.remove(position); // 删除list对应条目 sa.notifyDataSetChanged(); // 更新布局显示 &#125; &#125;).create().show(); return true; &#125;&#125;);¶ 五、课后实验结果截图点击电话号码可以拨打电话步骤：修改电话号码空间为Button获取“拨打电话”权限&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt;设置监听器12345678910getPhone.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (!phoneNumber.equals("无") &amp;&amp; ActivityCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CALL_PHONE) == PackageManager.PERMISSION_GRANTED) &#123; Intent call = new Intent(Intent.ACTION_CALL, Uri.parse("tel:" + phoneNumber)); startActivity(call); Log.d("TAG", "calling"); &#125; &#125;&#125;);Github]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Android】Lab7_数据存储（一）]]></title>
    <url>%2F%E3%80%90Android%E3%80%91Lab7-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[¶ 一、实验题目数据存储（一）¶ 二、实验目的学习 SharedPreferences 的基本使用；学习 Android 中常见的文件操作方法；复习 Android 界面编程。¶ 三、实现内容首先，需要实现一个密码输入 activity：a、 如果应用首次启动，则界面呈现出两个输入框，分别为新密码输入和确认密码输入框；b、 输入框下方有两个按钮：OK 按钮，点击之后：若 new password 为空，则弹出密码为空的提示；若 new password 与 comfirm password 不匹配，则弹出不匹配的提示；若密码不为空且互相匹配，则保存密码，进入文件编辑界面。CLEAR 按钮，点击之后清除所有输入框的内容。c、 完成创建密码后，退出应用再进入应用，则只呈现一个密码输入框；点击 OK 按钮后，如果输入的密码与保存的密码不匹配，则弹出 Toast 提示；点击 CLEAR 按钮后，清除密码输入框的内容。d、 出于学习的目的，我们使用 SharedPreferences 来保存密码，但是在实际应用中我们会用更安全的机制来保存这些隐私信息， 更多可以参考链接一和链接二。然后，实现一个文件编辑 activity：a、界面底部有两行四个按钮， 第一行三个按钮高度一致，顶对齐，按钮水平均匀分布。 按钮上方除了 ActionBar 和 StatusBar 之外的空间由标题和两个 EditText 占据， 文件内容编辑的 EditText 需要占据除去其他控件的全部屏幕空间，且内部文字竖直方向置顶，左对齐；b、 在文件名输入框内输入文件名， 在文件内容编辑区域输入任意内容， 点击 SAVE 按钮后能够保存到指定文件，成功保存后弹出 Toast 提示；c、 点击 CLEAR 按钮，能够清空文件内容编辑区域内的内容；d、 点击 LOAD 按钮，能够按照文件名从内存中读取文件内容，并将文件内容写入到编辑框中。如果成功导入，则弹出成功的 Toast 提示， 如果导入失败（例如：文件不存在）， 则弹出读取失败的 Toast 提示。e、 点击 DELETE 按钮，能够按照文件名从内容中删除文件，删除文件后再载入文件，弹出导入失败的 Toast 提示。特殊要求：进入文件编辑的 Activity 之后，如果点击返回按钮，则直接返回 Home 界面，不再返回密码输入界面。¶ 四、课堂实验结果1、实验截图从左至右， 依次为：初始密码界面、密码为空提示、 密码匹配后重新进入界面、 密码错误提示。从左至右，依次为：保存成功提示、写入失败提示、 写入成功提示、删除成功提示。2、实验步骤以及关键代码1） MainActivity布局activity_main1234567891011121314151617181920212223242526272829303132333435363738394041&lt;RelativeLayout android:layout_width="wrap_content" android:layout_height="wrap_content" app:layout_constraintTop_toTopOf="parent" app:layout_constraintBottom_toBottomOf="parent"&gt; //整体居中 &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical" android:id="@+id/edit"&gt; &lt;EditText android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/newPW" android:hint="New Password" android:inputType="numberPassword"/&gt; &lt;EditText android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/confirmPW" android:hint="Confirm Password" android:inputType="numberPassword" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal" android:id="@+id/btn" android:layout_below="@id/edit"&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/ok" android:text="OK"/&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/cls" android:text="CLEAR"/&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt;MainActivity.java使用SharePreferences存储密码创建SharePreferences对象sp，调用函数getSharedPreferences(String, int)获取对象String：name，指定文件名称，如果文件不存在则会创建一个int：mode，指定操作模式，默认操作0，即MODE_PRIVATE，只允许创建程序可以读写创建SharedPreferences.Editor 对象spe，进行文件的编辑(内容可以是整型、 布尔型、 浮点型和长整型等 )spe.putString(&quot;Password&quot;, str2)写入密码spe.apply()提交保存sp.getString(&quot;Password&quot;, null)读取数据第一个参数是Key，第二参数是默认value，但根据Key找不到对应值时返回默认值根据ok/clear按钮不同功能设置监听器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455sp = getSharedPreferences("Password", 0);spe = sp.edit();storage = sp.getString("Password", null);if(storage != null) &#123; is_registed = true; newPW.setVisibility(View.INVISIBLE); confirmPW.setHint("Password");&#125;/* *点击ok按钮保存密码/进入文件编辑 */ok = (Button)findViewById(R.id.ok);ok.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; str1 = newPW.getText().toString(); str2 = confirmPW.getText().toString(); if(is_registed) &#123;//密码已保存 if(str2.isEmpty()) &#123;//密码为空 Toast.makeText(MainActivity.this, "Password cannot be empty", Toast.LENGTH_SHORT).show(); &#125; else &#123; if(str2.equals(storage)) &#123;//密码正确 Intent intent = new Intent(); intent.setClass(MainActivity.this, FileEditor.class); startActivity(intent); &#125; else &#123;//与保存密码不匹配 Toast.makeText(MainActivity.this, "Password Mismatch", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; else &#123;//未保存密码 if(str1.isEmpty() || str2.isEmpty()) &#123;//密码为空 Toast.makeText(MainActivity.this, "Password cannot be empty", Toast.LENGTH_SHORT).show(); &#125;else if(str2.equals(str1))&#123;//密码匹配 spe.putString("Password", str2); spe.apply(); Intent intent = new Intent(); intent.setClass(MainActivity.this, FileEditor.class); startActivity(intent); &#125;else &#123;//密码不匹配 Toast.makeText(MainActivity.this, "Password Mismatch", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;&#125;);/* *点击clear按钮清空密码 */cls = (Button)findViewById(R.id.cls);cls.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; newPW.setText(""); confirmPW.setText(""); &#125;&#125;);​2）FileEditor布局activity_file_editor在线性布局LinearLayout中根据比例设置EditText的大小，以及三个按钮水平均匀分布layout_weight12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="30sp" android:text="File Editor" android:textColor="#ff8b008b" android:layout_gravity="center" /&gt; &lt;EditText android:id="@+id/fileName" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_weight="1" android:hint="File Name" /&gt; &lt;EditText android:id="@+id/fileContent" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_weight="13" android:hint="File Content Here" android:gravity="top"/&gt; &lt;LinearLayout android:orientation="horizontal" android:id="@+id/FileButtons" android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_weight="1" &gt; &lt;Button android:id="@+id/save" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_weight="1" android:layout_marginRight="20dp" android:text="SAVE" /&gt; &lt;Button android:id="@+id/load" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_weight="1" android:text="LOAD" /&gt; &lt;Button android:id="@+id/clear" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_weight="1" android:layout_marginLeft="20dp" android:text="CLEAR" /&gt; &lt;/LinearLayout&gt; &lt;Button android:id="@+id/delete" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="DELETE" android:textColor="#ffff0000"/&gt;&lt;/LinearLayout&gt;FileEditor.java定义文件存储的方法SaveFile：调用openFileOutput(String, int)创建一个FileOutputStream对象String：name，文件名称，不能包含路径（‘/’）int：mode，文件操作模式，默认0，即MODE_PRIVATE，如果指定相同文件名，新编辑信息覆盖原文件内容；8，MODE_APPEND表示文件已存在，往原文件后面追加内容。output.write(content.getBytes())将数据以Byte数组的形式写入文件output.flush()将所有剩余的数据写入文件 （为了提高文件系统的性能，一般调用write()函数时，如果写入的数据量较小，系统会把数据保存在数据缓冲区中，等数据量累积到一定程度时再一次性的写入文件中 ）output.close()关闭文件LoadFile：调用openFileInput(String)创建一个FileInputStream对象String：name，文件名称，不能包含路径（‘/’）byte[] contents = new byte[input.available()]创建byte数组用于存读取的文件input.available()获取文件大小input.read(contents)读取文件，写入contentsinput.close()关闭文件最后return，返回String格式的文件内容DeleteFile：直接调用系统提供的方法deleteFile(String)String：name，文件名称，不能包含路径（‘/’）接着，根据各个按钮功能设置监听器，执行相关操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 保存文件public void SaveFile(String name, String content)&#123; try &#123; FileOutputStream output = openFileOutput(name, 0); output.write(content.getBytes()); output.flush(); output.close(); Toast.makeText(this, "Save Successfully", Toast.LENGTH_SHORT).show(); &#125; catch (IOException ex) &#123; Toast.makeText(this, "Fail to save file", Toast.LENGTH_SHORT).show(); &#125;&#125;// 读取文件public String LoadFile(String name) &#123; try &#123; FileInputStream input = openFileInput(name); byte[] contents = new byte[input.available()]; input.read(contents); input.close(); Toast.makeText(this, "Load Successfully", Toast.LENGTH_SHORT).show(); return new String(contents); &#125; catch (IOException ex) &#123; Toast.makeText(this, "Fail to load file", Toast.LENGTH_SHORT).show(); &#125; return "";&#125;// 删除文件public void DeleteFile(String name) &#123; deleteFile(name); Toast.makeText(this, "Delete succesfully", Toast.LENGTH_SHORT).show();&#125;//保存(调用SaveFile方法)Button save = (Button) findViewById(R.id.save);save.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SaveFile(fileName.getText().toString(), fileContent.getText().toString()); &#125;&#125;);//读取(调用LoadFile方法)Button load = (Button) findViewById(R.id.load);load.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; fileContent.setText(LoadFile(fileName.getText().toString())); &#125;&#125;);//清空（直接将文本内容设为""）Button clear = (Button) findViewById(R.id.clear);clear.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; fileContent.setText(""); &#125;&#125;);//删除（调用DeleteFile方法）Button delete = (Button) findViewById(R.id.delete);delete.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; DeleteFile(fileName.getText().toString()); &#125;&#125;);¶ 五、课后实验结果截图实现多用户登录从左至右，依次为：登录界面、用户名为空、 用户不存在或密码错误。从左至右，依次为：注册界面、文件编辑界面、 当前用户不能访问其他用户的文件。步骤：再添加一个注册用户的Activity，每次点击按钮且满足一定条件就根据用户名创建一个SharedPreferences对象，将密码保存再该对象里面；注册成功后就可以直接跳转到文件编辑Activity，并且传入该用户名；文本编辑Activity，读取和写入文件，都自动在文件名前面加上用户名作为识别标识，以防止其他用户访问；返回回到登录界面，而不是注册界面（注册Activity noHistory=true）登录界面，用户名和密码不匹配，就会弹出“User does not exist or Password error”，成功输入用户和密码就可以跳转到文本编辑界面。123456789101112131415161718192021222324252627282930/* *点击ok创建账号 */Button ok = (Button) findViewById(R.id.ok);ok.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; str1 = user.getText().toString(); str2 = newPW.getText().toString(); str3 = confirmPW.getText().toString(); if (str1.isEmpty())&#123; Toast.makeText(CreateAccount.this, "Username cannot be empty", Toast.LENGTH_SHORT).show(); &#125; else if (str2.isEmpty() || str3.isEmpty())&#123; Toast.makeText(CreateAccount.this, "Password cannot be empty", Toast.LENGTH_SHORT).show(); &#125; else if(str3.equals(str2)) &#123; SharedPreferences sp = getSharedPreferences(str1, MODE_PRIVATE); // 创建SharedPreferences对象 SharedPreferences.Editor spe = sp.edit(); spe.putString("Password", str2); // 存入对应密码 spe.apply(); Intent intent = new Intent(); intent.setClass(CreateAccount.this, FileEditor.class); intent.putExtra("Username", str1); startActivity(intent); &#125; else &#123; Toast.makeText(CreateAccount.this, "Password Mismatch", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125;);Github]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Android】Lab6_服务与多线程——简单音乐播放器]]></title>
    <url>%2F%E3%80%90Android%E3%80%91Lab6-%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%2F</url>
    <content type="text"><![CDATA[¶ 一、实验题目服务与多线程–简单音乐播放器¶ 二、实验目的学会使用 MediaPlayer；学会简单的多线程编程，使用 Handle 更新 UI；学会使用 Service 进行后台工作；学会使用 Service 与 Activity 进行通信。¶ 三、实现内容播放、暂停、停止、退出功能；后台播放功能；进度条显示播放进度、拖动进度条改变进度功能；播放时图片旋转，显示当前播放时间功能。¶ 四、课堂实验结果1、实验截图动态获取权限启动界面播放拉动进度条/暂停停止2、实验步骤以及关键代码1） 创建一个音乐服务（MusicService）。服务（Service）是一种可以在后台执行长时间运行操作而没有用户界面的应用组件。该服务将由主活动（MainActivity）启动，一旦被启动将在后台一直运行，即使启动服务的组件（MainActivity）已销毁也不受影响。右键com.example.xx -&gt; new -&gt; service123456789101112131415161718192021222324252627282930313233343536373839404142public class MusicService extends Service &#123; public MusicService() &#123; try &#123; //获取音频文件 mp.setDataSource(Environment.getExternalStorageDirectory() + "/melt.mp3"); mp.prepare(); mp.setLooping(true); super.onCreate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override //服务创建的时候调用 public void onCreate() &#123; super.onCreate(); &#125; @Override //被启动时回调该方法 public int onStartCommand(Intent intent, int flags, int startId) &#123; return super.onStartCommand(intent, flags, startId); &#125; @Override //回调绑定Service的接口binder public IBinder onBind(Intent intent) &#123; return binder; &#125; @Override //重载解除绑定的方法 public boolean onUnbind(Intent intent) &#123; return super.onUnbind(intent); &#125; @Override //服务销毁的时候调用 public void onDestroy() &#123; if (mp != null) &#123; mp.stop(); mp.reset(); mp.release();//停止播放并释放资源 &#125; super.onDestroy(); &#125;2） 在服务中实现多媒体的相关操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546//播放or暂停public void play() &#123; if (mp.isPlaying()) &#123; mp.pause(); state = 0; &#125; else &#123; mp.start(); state = 1; &#125;&#125;//停止public void Stop() &#123; if (mp != null) &#123; mp.stop(); state = ‐1; try &#123; mp.prepare(); mp.seekTo(0); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;//返回歌曲当前时间public int getCurrentTime() &#123; return mp.getCurrentPosition();&#125;//返回歌曲总时长public int getDuration() &#123; return mp.getDuration();&#125; //返回播放器状态，state ‐1停止/0暂停/1播放public int getState() &#123; return state;&#125;3） MyBinder类实现交互的方法onTranscant，因为IBinder的对象只提供一个消息传接接口，只能通过int类型的输入参数code对消息进行识别和判断，而交互数据都被封装在Parcel中12345678910111213141516171819202122232425262728293031323334public class MyBinder extends Binder &#123; @Override protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case 101: // 播放 play(); break; case 102: // 停止 MusicService.this.Stop(); break; case 103: // 退出 onDestroy(); break; case 104: // 刷新界面（绑定数据，写入到Parcel对象中） Bundle bundle = new Bundle(); bundle.putInt("current", getCurrentTime()); bundle.putInt("total", MusicService.this.getDuration()); bundle.putInt("state", getState()); reply.writeBundle(bundle); break; case 105: // 拖动进度条（从Parcel中读取拖动进度条的数据信息） int i = data.readInt(); Log.d("jumpTime", String.valueOf(i)); mp.seekTo(i); break; &#125; return super.onTransact(code, data, reply, flags); &#125;&#125;4）在Activity中启动service 两种模式：startService(intent)无法与Activity交互，独立运行知道stopService结束intent：通过事件指定要启动的服务bindService(Intent service, ServiceConnection conn, int flags)，进行Activity交互，生命与Activity一致，Activity退出调用unbindService。service：指定要绑定的服务conn：监听Activity与service的连接情况，需要重载两个方法，连接成功时回调onServiceConnected得到IBinder的实例，解除绑定的时候回调 onServiceDisconnectedflags：绑定时是否自动创建Service。（自动或不自动）123456789101112131415private ServiceConnection sc = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mBinder = service; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; sc = null; &#125;&#125;;final Intent intent = new Intent(this,MusicService.class);//开启服务startService(intent);//绑定activity和服务bindService(intent, sc, Context.BIND_AUTO_CREATE);5）新线程处理耗时工作以及Activity与Service交互 在Activity中使用匿名类的方式创建一个子线程，调用Thread的start()方法启动线程。 在子线程中更新UI（run函数处理耗时工作），但是Android的UI时线程不安全的，也就说，要更新UI线程必须在主线程中。不过，Android提供了一套异步消息处理机制，这里使用的是Handler机制。handler顾名思义是处理者的意思，用于发送和处理消息。子线程中每隔一段时间通过一个Handler对象发送一个Message，包含处理Message的对象还有消息的内容；这些消息存放在在MessageQueue中；looper无限循环，发现有消息加入MessageQueue，通过FIFO取出消息；交由handleMessage（需要重载该方法）处理消息。 进度条更新：通过上面onServiceConnected的连接服务得到了一个IBinder接口对象mBinder，将我们需要的操作方式int code传入transact中，交由Service处理，data是我们要传入的数据，在拉动进度条时需要传入相关数据，reply是我们从Service得到的数据，例如播放器的状态、音乐时长，当前时间点。这里得到的时间需要通过time.format来格式化。SimpleDateFormat mFormat = new SimpleDateFormat(&quot;mm:ss&quot;);123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 新建线程（负责耗时工作）new Thread(new Runnable() &#123; @Override public void run() &#123; do &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (sc != null &amp;&amp; hasPermission) &#123; // 构造消息并发送 mHandler.obtainMessage(123).sendToTarget(); &#125; &#125; while (true); &#125;&#125;).start();//UI线程与子线程交互final Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case 123: try &#123; int code = 104; int flag; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); if(mBinder != null) &#123; mBinder.transact(code, data, reply, 0); Bundle bundle = reply.readBundle(getClass().getClassLoader()); mCurrentTime.setText(mFormat.format(bundle.getInt("current"))); mTotalTime.setText(mFormat.format(bundle.getInt("total"))); mSeekBar.setProgress(bundle.getInt("current")); mSeekBar.setMax(bundle.getInt("total")); flag = bundle.getInt("state"); if (flag == 0) &#123; mState.setText("Paused"); mPlay.setText("PLAY"); rotate = false; &#125; else if (flag == 1) &#123; mState.setText("Playing"); mPlay.setText("PAUSED"); rotate = true; &#125; else if (flag == ‐1) &#123; mState.setText("Stopped"); mPlay.setText("PLAY"); mImage.setRotation(0); rotate = false; &#125; else &#123; mState.setText(""); &#125; &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; if (rotate) &#123; // 旋转处理，每次转到1° degree += 1; mImage.setRotation(degree); &#125; break; &#125; &#125;&#125;;动态文件读取申请 确保用户隐式安全，通过弹出对话框询问是否给予权限，如果点击拒绝，就会退出，就算Service得到文件也无法进行相关操作 注册权限（AndroidManifest.xml）&lt;uses-permissionandroid:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;;123456789101112131415161718192021222324252627//检查是否有读取权限public static void verifyStoragePermissions(Activity activity) &#123; try &#123; int permission = ActivityCompat.checkSelfPermission(activity, Manifest.permission.READ_EXTERNAL_STORAGE); if (permission != PackageManager.PERMISSION_GRANTED) &#123; // 没有读取权限，申请权限弹出对话框 ActivityCompat.requestPermissions(activity, PERMISSIONS_STORAGE, REQUEST_EXTERNAL_STORAGE); &#125; else &#123; hasPermission = true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;//重载权限申请方法@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // 同意权限 &#125; else &#123; // 拒绝权限 System.exit(0); &#125; super.onRequestPermissionsResult(requestCode, permissions, grantResults);&#125;¶ 五、课后实验结果截图前台服务，点击查看后台服务或停止服务服务的优先级比较低，当系统出现内存不足的情况时，就有可能回收后台服务。如果我们希望服务能一直保持运行，就可以使用前台服务。前台服务的设置类似于广播的效果，都是显示在通知栏，不过广播使用的时NotificationManager来显示通知，而前台服务时通过startForeground来启动。1234567891011121314151617@Overridepublic void onCreate() &#123; super.onCreate(); String MusicName = "Melt"; Bitmap bitmap = BitmapFactory.decodeResource(this.getResources(), R.drawable.image); Notification.Builder builder = new Notification.Builder(this); builder.setContentTitle(MusicName) .setLargeIcon(bitmap) .setWhen(getCurrentTime()) .setAutoCancel(true); Intent mIntent = new Intent(this, MainActivity.class); PendingIntent pi = PendingIntent.getActivity(this, 0, mIntent, PendingIntent.FLAG_UPDATE_CURRENT); builder.setContentIntent(pi); Notification notify = builder.build(); startForeground(1, notify);&#125;Github]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Android】Lab5_Appwidget及Broadcast使用]]></title>
    <url>%2F%E3%80%90Android%E3%80%91Lab5-Appwidget%E5%8F%8ABroadcast%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[¶ 一、实验题目appwidget 及broadcast 使用¶ 二、实验目的掌握 AppWidget 编程基础掌握 Broadcast 编程基础掌握动态注册 Broadcast 和静态注册 Broadcast¶ 三、实现内容实现一个Android 应用，实现静态广播、动态广播两种改变widget 内容的方法。在上次实验的基础上进行修改，所以一些关于静态动态广播的内容会简略。具体要求:点击widget可以启动应用，并在widget随机推荐一个商品点击widget跳转到该商品详情界面点击购物车图标，widget相应更新点击widget跳转到购物车界面实现方式要求:启动时的widget的更新通过静态广播实现，点击购物车图标时候widget的更新通过动态广播实现。¶ 四、课堂实验结果1、实验截图2、实验步骤以及关键代码1）创建一个Widget类，同时包含了一个边框、一个框架和图形控件以及其他元素2）修改Widget的初始文件m_widget_info.xmlinitialLayout指向widget显示桌面的布局资源m_widget.xmlpreviewImage指定默认图标updatePeriodMills自定义更新时间间隔，默认30minminWidth和minHeight指定Widget占用的最小空间3）修改Widget的布局文件m_widget.xml12345678910111213141516171819202122232425262728&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="@dimen/widget_margin" android:id="@+id/widget"&gt; // 设定id &lt;ImageView android:id="@+id/appwidget_icon" android:layout_width="100dp" android:layout_height="match_parent" android:src="@mipmap/shoplist" android:layout_gravity="center_vertical" android:contentDescription="@string/appwidget_text"/&gt; &lt;TextView android:id="@+id/appwidget_text" android:gravity="center" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_margin="8dp" android:contentDescription="@string/appwidget_text" android:text="@string/appwidget_text" android:textColor="#ffffff" android:textSize="15sp" android:textStyle="bold|italic" /&gt;&lt;/LinearLayout&gt;4）注册Widget的静态广播12345678910&lt;receiver android:name=".mWidget"&gt; &lt;intent-filter&gt; &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE" /&gt; &lt;action android:name="STATIC_ACTION" /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name="android. " android:resource="@xml/m_widget_info" /&gt;&lt;/receiver&gt;5）启动随机广播，沿用上次实验代码，不需要修改6）接收静态广播，修改Widget的类mWidget.java重载onUpdate方法，间隔性更新Widget12345678910111213141516171819static void updateAppWidget(Context context, AppWidgetManager appWidgetManager, int appWidgetId) &#123; RemoteViews updateViews = new RemoteViews(context.getPackageName(),R.layout.m_widget);// 实例化RemoteView,其对应相应的Widget布局 Intent i = new Intent(context, MainActivity.class); PendingIntent pi = PendingIntent.getActivity(context, 0, i, PendingIntent.FLAG_UPDATE_CURRENT);// pendingIntent是一种特殊的Intent，其执行不是立刻的 updateViews.setOnClickPendingIntent(R.id.widget, pi);// 给RemoteView上的Button设置按钮事件 ComponentName me = new ComponentName(context, mWidget.class); appWidgetManager.updateAppWidget(me, updateViews);&#125;@Overridepublic void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123; for (int appWidgetId : appWidgetIds) &#123; updateAppWidget(context, appWidgetManager, appWidgetId); &#125;&#125;重载onReceiver方法，接收广播时调用123456789101112131415161718192021222324@Overridepublic void onReceive(Context context, Intent intent) &#123; super.onReceive(context, intent); if(intent.getAction().equals("STATIC_ACTION")) &#123; Bundle bundle = intent.getExtras(); Intent i = new Intent(context, GoodsInformation.class); i.addCategory(Intent.CATEGORY_LAUNCHER); i.putExtras(intent.getExtras()); RemoteViews updateViews = new RemoteViews(context.getPackageName(), R.layout.m_widget); PendingIntent pi = PendingIntent.getActivity(context, 0, i, PendingIntent.FLAG_UPDATE_CURRENT); updateViews.setOnClickPendingIntent(R.id.widget, pi);//给RemoteView上的Button设置按钮事件 updateViews.setTextViewText(R.id.appwidget_text, bundle.getString("name")+"仅售"+bundle.getString("price")+"!"); updateViews.setImageViewResource(R.id.appwidget_icon, bundle.getInt("icon")); ComponentName me = new ComponentName(context, mWidget.class); //获取AppWidgetManager实例 AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context); appWidgetManager.updateAppWidget(me, updateViews); &#125;&#125;7）设置动态广播，修改上次实验动态广播类123456789101112131415161718192021222324public class DynamicReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if(intent.getAction().equals("DYNAMIC_ACTION")) &#123; /* * 通知栏动态广播 */ // Widget的动态广播通过RemoteViews实现 RemoteViews updateViews = new RemoteViews(context.getPackageName(), R.layout.m_widget); mIntent.addCategory(Intent.CATEGORY_DEFAULT); PendingIntent pi = PendingIntent.getActivity(context, 0, mIntent, PendingIntent.FLAG_UPDATE_CURRENT); updateViews.setTextViewText(R.id.appwidget_text, bundle.getString("name")+"已添加到购物车"); updateViews.setImageViewResource(R.id.appwidget_icon, bundle.getInt("icon")); updateViews.setOnClickPendingIntent(R.id.widget, pi);//给RemoteView上的Button设置按钮事件 ComponentName me = new ComponentName(context, mWidget.class); //获取AppWidgetManager实例 AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context); appWidgetManager.updateAppWidget(me, updateViews); &#125; &#125;&#125;Github]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Android】Lab4_Broadcast使用]]></title>
    <url>%2F%E3%80%90Android%E3%80%91Lab4-Broadcast%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[¶ 一、实验题目Broadcast 使用¶ 二、实验目的1、掌握 Broadcast 编程基础2、掌握动态注册 Broadcast 和静态注册 Broadcast3、掌握Notification 编程基础4、掌握 EventBus 编程基础¶ 三、实现内容在实验三的基础上，实现静态广播、动态广播两种改变Notification 内容的方法。具体要求：在启动应用时，会有通知产生，随机推荐一个商品点击通知跳转到该商品详情界面点击购物车图标，会有对应通知产生，并通过Eventbus在购物车列表更新数据点击通知返回购物车列表实现方式要求:启动页面的通知由静态广播产生，点击购物车图标的通知由动态广播产生。¶ 四、课堂实验结果1、实验截图2、实验步骤以及关键代码1）设置静态广播（在启动应用时，会有通知产生，随机推荐一个商品，点击通知跳转到该商品详情界面）产生随机数（根据商品列表大小，产生0~9的数）12Random random = new Random();int index = random.nextInt(goodsList.size());注册静态广播12345678&lt;receiver android:name=".StaticReceiver" android:enabled="true" android:exported="true" android:permission="true"&gt; &lt;intent-filter&gt; &lt;action android:name="STATIC_ACTION"/&gt; //记录广播的名称 &lt;/intent-filter&gt;&lt;/receiver&gt;发送广播1234567Bundle bundle = new Bundle(); //bundle捆绑数据bundle.putString("name", goodsList.get(index).get("name").toString());bundle.putString("price", goodsList.get(index).get("price").toString());bundle.putInt("icon", (Integer) goodsList.get(index).get("icon"));Intent intentBroadcast = new Intent("STATIC_ACTION"); intentBroadcast.putExtras(bundle);sendBroadcast(intentBroadcast); //发送广播接收广播1234567891011121314151617181920212223242526272829303132333435363738public class StaticReceiver extends BroadcastReceiver &#123; //创建一个静态广播类 @Override public void onReceive(Context context, Intent intent) &#123; //重写onReceiver if(intent.getAction().equals("STATIC_ACTION")) &#123; //判断是否是要接受的广播 //从资源中获取位图 Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), bundle.getInt("icon")); //获取状态通知栏管理 NotificationManager manager = (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE); //实例化通知栏构造器 //Notification.Builder builder = new Notification.Builder(context); NotificationCompat.Builder builder = new NotificationCompat.Builder(context); //对builder进行配置 /* 设置通知栏标题 设置通知栏显示内容 通知首次出现在通知栏,带上升动画效果的 设置大ICON 设置小icon 设置这个标志当用户单击面板就可以将通知取消 */ builder.setContentTitle("新商品热卖") .setContentText(bundle.getString("name")+"仅售"+bundle.getString("price")) .setTicker("您有一条新消息") .setLargeIcon(bitmap) .setSmallIcon(bundle.getInt("icon")) .setWhen(System.currentTimeMillis()) .setAutoCancel(true); //绑定intent，点击图标能够进入商品详情活动 Intent mInent = new Intent(context, GoodsInformation.class); mInent.putExtra("name", bundle.getString("name")); PendingIntent mPendingIntent = PendingIntent.getActivity(context, 0, mInent, PendingIntent.FLAG_ONE_SHOT); builder.setContentIntent(mPendingIntent); //绑定Notification，发送通知请求 Notification notify = builder.build(); manager.notify(0, notify); &#125; &#125;&#125;2）设置动态广播（点击购物车图标产生通知）注册广播（在Activity中）123IntentFilter dynamicFilter = new IntentFilter();dynamicFilter.addAction("DYNAMIC_ACTION"); //指定广播名称registerReceiver(dynamicReceiver, dynamicFilter);发送广播设置与静态广播相似，只是当点击购物车图标时才产生广播12345cart.setOnClickListener(new View.OnClickListener() &#123; bundle 绑定数据 intent.putExtras(bundle) sendBroadcast(intent)发送广播&#125;);接收广播123456789101112131415161718public class DynamicReceiver extends BroadcastReceiver &#123; //创建一个动态广播类 @Override public void onReceive(Context context, Intent intent) &#123; //重载onReceiver if(intent.getAction().equals("DYNAMIC_ACTION")) &#123; //接收特定广播 /** *Notification相关属性的设置与静态广播的相似 *不同之处在于点击通知跳转到购物车列表（MainActivity） *同时能够显示多条广播 */ //绑定intent，点击图标能够进入购物车列表（主活动） Intent mInent = new Intent(context, MainActivity.class); mInent.putExtra("shoppingList", "run"); //使用时间作为id，可以显示多条通知 manager.notify((int)System.currentTimeMillis(),notify); &#125;&#125;MainActivity中有两个列表，默认的是商品列表，点击通知时切换到购物车列表12345678910111213@Overrideprotected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); Bundle extras = intent.getExtras(); if(extras != null) &#123; if(extras.getString("shoppingList").equals("run")) &#123; goodsRecyclerView.setVisibility(View.GONE); shopListView.setVisibility(View.VISIBLE); switchButton.setImageResource(R.drawable.mainpage); &#125; &#125; setIntent(intent);&#125;注销广播1unregisterReceiver(dynamicReceiver);3）点击购物车图标，通过Eventbus在购物车列表更新数据创建一个事件类，用于传递信息123456789101112131415public class MessageEvent &#123; private String name; private String price; public MessageEvent(String name, String price) &#123; super(); this.name = name; this.price= price; &#125; public String getName() &#123; return name; &#125; public String getPrice() &#123; return price; &#125;&#125;注册订阅者（MainActivity）1EventBus.getDefault().register(this);准备订阅者（shoplist）12345678910111213@Subscribe(threadMode = ThreadMode.MAIN) public void onMessageEvent(MessageEvent event) &#123; String name = event.getName(); String price = event.getPrice(); if (name != null &amp;&amp; price !=null) &#123; Map&lt;String, Object&gt; tmp = new LinkedHashMap&lt;&gt;(); tmp.put("letter", name.substring(0, 1)); tmp.put("name", name); tmp.put("price", price); shopList.add(tmp); simpleAdapter.notifyDataSetChanged(); &#125; &#125;传递消息（单击购物车图标响应）1EventBus.getDefault().post(new MessageEvent(choiceName, choicePrice));注销订阅者1EventBus.getDefault().unregister(this);Github]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Android】Lab3_Intent、Bundle的使用以及RecyclerView、ListView的应用]]></title>
    <url>%2F%E3%80%90Android%E3%80%91Lab3-Intent%E3%80%81Bundle%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8ARecyclerView%E3%80%81ListView%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[¶ 一 实验目的复习事件处理学习Intent、bundle在Activity跳转中的应用学习Recyleview、ListView以及各类适配器的用法¶ 二 实现内容1、商品表界面每一项为一个圆圈和一个名字，圆圈与名字均竖直居中。圆圈中为字母的首字母，首字母要出于圆圈的中心，首字母为白色，名字为黑色，圆圈的颜色自定义。2、购物列表界面在商品表界面的基础上增加一个价格，价格为黑色3、商品详情界面顶部顶部占整个界面的1/3，图片与这块view等高。返回图标出于这块view的左上角，商品名字出于左下角，星标处于右下角，它们与边距有一定距离。返回图标与名字左对齐，名字与星标底边对齐。4、商品详情界面中部使用的黑色 argb 编码值为#D5000000，稍微偏灰色一点的“类型”、“其他信息”的 argb 编码值为#8A000000。价格那一栏的下边有一条分割线，argb 编码值为 #1E000000，右边购物车符号的左边也有一条分割线，argb 编码值也是#1E000000，这条分割线要求高度与购物车符号的高度一致，并且竖直居中。字体的大小看着调就可以了。“更多资料”底部的分割线高度自定，argb 编码值与前面的分割线一致。5、商品详情界面底部6、两个都没有标题栏¶ 三、课堂实验结果¶ 1 实验截图商品列表界面长按删除商品详情界面购物车列表购物车删除¶ 2 实验步骤以及关键代码1、先去掉标题栏在配置文件AndroidMainifest.xml中，可以看到Android Studio创建项目时默认的theme是：123&lt;application android:theme="@style/AppTheme"&gt;&lt;/application&gt;打开文件res/values/styles.xml12345&lt;resources&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; //去掉标题 属性parent DarkActionBar改为NoActionBar &lt;/style&gt;&lt;/resources&gt;2、使用RecyclerView实现商品列表RecycleView 是Android 5.0推出的，support-v7包中提供的新组件，最低兼容到Android 3.0。2.1 添加依赖build.gradle(Project:lab3)，在新版Android Studio中可以不用，已经集成好了函数google()12345678allprojects &#123; repositories &#123; jcenter() maven &#123; url "https://maven.google.com" &#125; &#125;&#125;build.gradle(Moudle:app)1compile 'com.android.support:recyclerview-v7:26.0.0-alpha1'2.2 xml布局主活动MainActivity中有两个列表：商品列表和购物车列表，为了区分，设置商品列表id为goodslist，visibility为visible，即显示。12345678&lt;android.support.v7.widget.RecyclerView xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/goodslist" android:visibility="visible" app:layout_constraintTop_toTopOf="parent" app:layout_constraintLeft_toLeftOf="parent" /&gt;没有结束，RecyclerView只是一个列表容器，我们还需要定义每一项的信息和样式新建一个layout文件，命名为item.xml，水平布局LinearLayout，包含两个TextView，分别为商品名以及其首个字母。123456789101112131415161718192021222324252627&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;TextView android:id="@+id/letter" android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:textSize="25sp" android:layout_margin="20dp" android:textColor="@color/white" android:background="@drawable/circle"/&gt; &lt;TextView android:id="@+id/name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:paddingTop="15dp" android:paddingBottom="15dp" android:layout_marginTop="20dp" android:text="goodsName" android:textSize="20sp" android:textColor="@color/black"/&gt;&lt;/LinearLayout&gt;定义首个字母样式，在drawable文件夹中新建一个xml文件，自定义样式12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!--大小--&gt; &lt;size android:height="50dp" android:width="50dp"/&gt; &lt;!--弧度--&gt; &lt;corners android:radius="25dp"/&gt; &lt;!--颜色--&gt; &lt;solid android:color="@color/colorPrimary"/&gt;&lt;/shape&gt;2.3 逻辑实现123、ListView创建空列表，id为shoppinglist即表示购物车列表， 在java文件中用适配器Adapter填充数据，数据包含商品名称name，商品价格price以及名称首字母letter。设置监听器，实现长按和单击不同的功能。.xml12345&lt;ListView android:id="@+id/shoppinglist" android:layout_width="0dp" android:layout_height="wrap_content" android:visibility="gone"/&gt; //隐藏布局，首页面为商品列表.java123456789101112131415shopListView = (ListView) findViewById(R.id.shoppinglist);simpleAdapter = new SimpleAdapter(this, shopList, R.layout.shoplist_layout, new String[]&#123;"letter", "name", "price"&#125;, new int[]&#123;R.id.letter, R.id.name, R.id.price&#125;);shopListView.setAdapter(simpleAdapter); //匹配数据 //长按shopListView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() &#123; @Override public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, final int position, long id) &#123;……&#125;&#125;);//单击shopListView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;……&#125;&#125;);RecycleView布局实现商品列表，id为goodslist。因为RecycleView是support-v7包中的新组建，提供了插拔式体验，相比LayoutView更加灵活。使用时需要添加相关依赖，具体操作可以快捷键ctrl+shift+Alt+s添加。RecycleView自定义实现RecycleView.VieWHolder，ViewHolder为的是ListView、RecycleView滚动时快速设置值，而不必每次重新创建很多对象。123456public class ViewHolder extends RecyclerView.ViewHolder &#123; //获取实例 public static ViewHolder get(Context context, ViewGroup parent, int itemId) &#123;……&#125; //将子view存入一个数组中 public &lt;T extends View&gt; T getView(int viewId) &#123;……&#125;&#125;RecycleView自定义实现RecycleView.Adapter，根据不同视图类型创建对应的布局，并且绑定数据。1234567891011121314public abstract class CommonAdapter extends RecyclerView.Adapter&lt;ViewHolder&gt;&#123; @Override //创建对应item视图，并返回相应的ViewHolder public ViewHolder onCreateViewHolder(final ViewGroup parent, int viewType) &#123;……&#125; @Override //绑定数据到正确的item视图上 public void onBindViewHolder(final ViewHolder holder, int position) &#123;…&#125; @Override //获取item视图总数 public int getItemCount() &#123;……&#125; public interface OnItemClickListener &#123;……&#125; //添加监听器接口函数，再在onBindViewHolder中绑定数据 public void setOnItemClickListener(OnItemClickListener onItemClickListener)&#123;……&#125;LayoutManager布局管理器，绑定数据；AnimationAdapter设置动画；OnItemClickListener设置监听器，实现单击与长按功能。12345678910 goodsRecyclerView = (RecyclerView) findViewById(R.id.goodslist);//匹配数据 goodsRecyclerView.setLayoutManager(new LinearLayoutManager(this)); //添加动画 animationAdapter = new ScaleInAnimationAdapter(goodsListAdapter); animationAdapter.setDuration(1000); goodsRecyclerView.setAdapter(animationAdapter); goodsRecyclerView.setItemAnimator(new OvershootInLeftAnimator()); //单击与长按 goodsListAdapter.setOnItemClickListener(new CommonAdapter.OnItemClickListener()&#123;……&#125;);商品列表与购物车列表实现在同一个Activity中，通过FloatingActionButton（需要添加依赖）图片按钮实现。12345678910111213141516switchButton = (FloatingActionButton)findViewById(R.id.switch_button); switchButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if(goodsRecyclerView.getVisibility() == view.VISIBLE) &#123; goodsRecyclerView.setVisibility(view.GONE); shopListView.setVisibility(View.VISIBLE); switchButton.setImageResource(R.drawable.mainpage); &#125; else if(shopListView.getVisibility() == view.VISIBLE) &#123; goodsRecyclerView.setVisibility(view.VISIBLE); shopListView.setVisibility(view.GONE); switchButton.setImageResource(R.drawable.shoplist); &#125; &#125; &#125;);创建新的活动，响应单击事件，并设置该活动布局。RelativeLayout: 相对布局，设置占顶部1/3的图片信息，包括商品图片、商品名字、返回按钮、收藏按钮；LinerLayout：线性布局，设置下面其他的列表信息，指定id，可以通过适配器匹配数据；View：通过设定背景颜色以及宽高来定义分隔线；设置事件响应，包括单击，返回等等123456789101112131415161718//单击跳转（活动1） public void onClick(int position) &#123; String goodsName = goodsList.get(position).get("name").toString(); Intent intent = new Intent(MainActivity.this, GoodsInformation.class); intent.putExtra("name", goodsName); startActivityForResult(intent, 1); &#125;//接收点击位置的参数（活动2） Bundle extras = getIntent().getExtras(); if(extras != null) &#123; data = extras.getString("name"); //“name”与活动1匹配 for(int i = 0; i &lt; inforList.size(); i++) &#123; if(inforList.get(i).get("name").toString().equals(data)) &#123; pos = i; &#125; &#125; &#125;//得到pos，就可以匹配相应的数据，再显示到布局Github]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Android】Lab2_事件处理]]></title>
    <url>%2F%E3%80%90Android%E3%80%91Lab2-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[¶ 一 实验题目1、了解 Android 编程基础2、熟悉 ImageView、Button、RadioButton 等基本控件，能够处理这些控件的基本事件3、学会弹出基本的对话框，能够定制对话框中的内容，能对确定和取消按钮的事件做处理¶ 二 实现内容实现一个 Android 应用，界面呈现要求如下：1、该界面为应用启动后看到的第一个界面2、输入学号和密码的控件要求用 TextInputLayout 实现3、点击图片，弹出对话框如下图：点击“拍摄”选项，弹出 Toast 信息“您选择了[拍摄]”；点击“从相册选择”选项，弹出 Toast 信息“您选择了[从相册选择]“；点击“取消”按钮，弹出 Toast 信息“您选择了[取消]”4、切换 RadioButton 的选项，弹出 Snackbar 提示“您选择了 xx”；例如从选项“学生”切换到选项“教职工”，则提示“您选择了教职工”；点击 Snackbar 上的“确定”按钮，则弹出 Toast 信息“Snackbar 的确定按钮被点击了”5、点击登录按钮 依次判断学号是否为空，密码是否为空，用户名和密码是否正确（正确的学号和密 码分别为“123456”，“6666”）；不正确则给出错误信息，如学号和密码都正确则提示“登陆成功”，如图：6、点击注册按钮 如果切换选项时，RadioButton 选中的是“学生”，那么弹出 Snackbar 信息“学生注册 功能尚未启用”，如果选中的是“教职工”，那么弹出 Toast 信息“教职工注册功能尚未启用”。¶ 三 课堂实验结果1、实验截图1）启动界面2）图片-&gt;对话框3）单选按钮4）登陆按钮5）注册按钮2、实验步骤以及关键代码布局xml文件1）启动界面，布局参照Lab12）添加TextInputLayout控件TextInputLayout 是 Android Design Support Library 中的一个控件，用于接受用户输入，与 EditText 配合使用有更好的用户体验， TextInputLayout 集合了输入提示，报错等功能， 并且自带动画效果。在lab1中可以看到，输入账号一行包括了TextView的文本提示，EditView的输入控件，如果需要统计字数，还需要再添加控件，而一个TextInputLayout控件可以解决这些问题。一个 TextInputLayout 中只能包含一个 EditText 。首先，添加依赖，位置build.gradle(Module:app)文件，添加1compile 'com.android.support:design:26.0.0-alpha1' // 选择合适的版本号也可以在File\Project Structure（快捷键Ctrl+Alter+Shift+S）中查找添加在修改了 build.gradle 文件之后，点击 Sync Now 同步项目。接着，xml布局文件中就可以使用TextInputLayout控件定义学号和密码123456789101112131415161718192021222324252627282930313233343536&lt;LinearLayout android:id="@+id/linearlayout" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical" android:layout_marginTop="20dp" app:layout_constraintTop_toBottomOf="@+id/imageView" app:layout_constraintRight_toRightOf="parent" app:layout_constraintLeft_toLeftOf="parent"&gt; &lt;android.support.design.widget.TextInputLayout android:id="@+id/editNum" android:layout_width="wrap_content" android:layout_height="wrap_content"&gt; &lt;EditText android:layout_width="wrap_content" android:layout_height="wrap_content" android:hint="请输入学号" android:textSize="18sp" android:ems="12" android:inputType="number"/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;android.support.design.widget.TextInputLayout android:id="@+id/editPW" android:layout_width="wrap_content" android:layout_height="wrap_content"&gt; &lt;EditText android:layout_width="wrap_content" android:layout_height="wrap_content" android:hint="请输入密码" android:textSize="18sp" android:ems="12" android:inputType="textPassword"/&gt; &lt;/android.support.design.widget.TextInputLayout&gt;&lt;/LinearLayout&gt;counterEnabled=“true” // 设置是否可以开启计数器，默认是falsecounterOverflowTextAppearance=&quot;&quot; // 计算器越位后的文字颜色和大小counterMaxLength=&quot;&quot; // 计算器的最大字数限制errorEnabled=“true” // 是否允许错误提示errorTextAppearance=&quot;&quot; // 错误提示的文字大小和颜色passwordToggleEnabled=“true” // 显示小眼睛passwordToggleTint=&quot;@color/colorAccent&quot; // 给小眼睛上色passwordToggleTintMode=“multiply” // 小眼睛的显示方式注意：显示小眼睛，需要设置为密码格式。逻辑实现java文件3）点击图片，弹出对话框首先创建一个对话框，对图像控件设置监听器，点击图片的时候触发，显示对话框。通过布局设定的id创建图像控件的一个对象，以便进行操作findViewById(R.id.xx)创建对话框AlertDialog.Builder 初始化一个对话框setTitle 设置标题setItems 设置对话框条目setPositiveButton 设置正向按钮setNegativeButton 设置反向按钮create 创建对话框show 显示对话框设置监听器第一处，对话框条目点击触发，弹出Toast信息。传入参数123456new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; // 执行操作，这里是弹出Toast信息 &#125;&#125;Toast.makeText(Context context, CharSequence text, int duration)context：上下文，MainActivity.this主活动页面 or getApplication()获取当前页面text：文本信息duration：显示持续时间，Toast.LENGTH_SHORT | Toast.LENGTH_LONG第二处，监听图像控件，通过setOnClickListener123456setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 执行操作，这里是显示对话框 &#125;&#125;);总体12345678910111213141516171819202122// 设置对话框final String[] items = &#123;"拍摄", "从相册选择"&#125;;final AlertDialog.Builder alertdialog = new AlertDialog.Builder(this);alertdialog.setTitle("上传图片") .setItems(items, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(getApplication(),"您选择了["+items[which]+"]", Toast.LENGTH_SHORT).show();&#125; &#125;) .setNegativeButton("取消", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(getApplication(),"您选择了[取消]",Toast.LENGTH_SHORT).show();&#125; &#125;).create();// 监听图片控件ImageView img=(ImageView)findViewById(R.id.imageView);img.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; alertdialog.show(); &#125;&#125;);4）单选按钮单选选项都是放在一个RadioGroup中，创建一个RadioGroup对象，设置监听器setOnCheckedChangeListener，监听选项的变化。用Snackbar代替Toast，获得更好的体验。make：创建，必须。三个参数（根布局、显示的消息、时长）setAction：监听右侧按钮，进行事件处理，两个参数（按钮显示的文本、处理点击事件的逻辑）setActionTextColor：设置按钮文本颜色setDuration：定义 Snackbar 弹 出时间长度，单位为 ms，当右侧按钮被点击之后， Snackbar 会立刻消失show：显示Snackbar1234567891011121314151617181920212223242526272829final RadioGroup RGroup = (RadioGroup)findViewById(R.id.RadioGroup);RGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(RadioGroup group, @IdRes int checkedId) &#123; if(checkedId == R.id.RB1) &#123; Snackbar.make(group,"您选择了[学生]",Snackbar.LENGTH_SHORT) .setAction("确定", new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Toast.makeText(getApplication(),"Snackerbar的确定按钮被点击了",Toast.LENGTH_SHORT).show(); &#125; &#125;) .setActionTextColor(getResources().getColor(R.color.colorPrimary)) .setDuration(5000) .show(); &#125; else &#123; Snackbar.make(group,"您选择了[教职工]",Snackbar.LENGTH_SHORT) .setAction("确定", new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Toast.makeText(getApplication(),"Snackerbar的确定按钮被点击了",Toast.LENGTH_SHORT).show(); &#125; &#125;) .setActionTextColor(getResources().getColor(R.color.colorPrimary)) .setDuration(5000) .show(); &#125; &#125;&#125;);5）登陆/注册getEditText()：获取TextInputLayout中的输入控件EditTextgetEditText().getText().toString()：读取输入控件EditText中文本并转为字符串setErrorEnabled：true，开启错误通知模式setError：设置错误提示文本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 关联布局控件final TextInputLayout NumText = (TextInputLayout)findViewById(R.id.editNum);final TextInputLayout PWText = (TextInputLayout)findViewById(R.id.editPW);// 获取TextInputLayout中的输入控件EditText NumEdit = NumText.getEditText();EditText PWEdit = PWText.getEditText();// 监听按钮控件Button btn1 = (Button)findViewById(R.id.btn1);btn1.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View view) &#123; String msg1 = ""; String getNum = NumText.getEditText().getText().toString(); String getPW = PWText.getEditText().getText().toString(); if (getNum.equals("123456") &amp;&amp; getPW.equals("6666")) &#123; msg1 = "登录成功"; &#125; else &#123; msg1 = "学号或密码错误"; &#125; Snackbar.make(view,msg1,Snackbar.LENGTH_SHORT) .setAction("确定", new View.OnClickListener()&#123; @Override public void onClick(View view) &#123; Toast.makeText(getApplication(),"Snackerbar的确定按钮被点击了",Toast.LENGTH_SHORT).show(); &#125; &#125;) .setActionTextColor(getResources().getColor(R.color.colorPrimary)) .setDuration(5000) .show(); if(getNum.length()==0) &#123; NumText.setErrorEnabled(true); NumText.setError("学号不能为空"); &#125; else if(getPW.length()==0) &#123; PWText.setErrorEnabled(true); PWText.setError("密码不能为空"); &#125; &#125;&#125;);Button btn2 = (Button)findViewById(R.id.btn2);btn2.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View view) &#123; String msg2 = ""; choice = RGroup.getCheckedRadioButtonId(); if (choice==R.id.RB1) &#123; msg2 = "学生注册尚未开启"; &#125; else &#123; msg2 = "教职工注册尚未开启"; &#125; Snackbar.make(view,msg2,Snackbar.LENGTH_SHORT) .setAction("确定", new View.OnClickListener()&#123; @Override public void onClick(View view)&#123; Toast.makeText(getApplication(),"Snackerbar的确定按钮被点击了",Toast.LENGTH_SHORT).show(); &#125; &#125;) .setActionTextColor(getResources().getColor(R.color.colorPrimary)) .setDuration(5000) .show(); &#125;&#125;);3、实验遇到困难以及解决思路1） 根据实验文档，修改build.graple文件，点击sync now显示错误，发现是版本号原因，由26/25联想到安装版本不同的api数，还要修改成与上文出现的版本号一致就解决了。2）在最后仿真的时候，手机上打不开应用，preview上提示Cannot resolve symbol id/vision，最后是在strings.xml或是colors.xml中添加相应的item。12&lt;item name="visible" type="id"/&gt;&lt;item name="masked" type="id"/&gt;Github]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Android】Lab1_基本UI界面设计]]></title>
    <url>%2F%E3%80%90Android%E3%80%91Lab1-%E5%9F%BA%E6%9C%ACUI%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[¶ 一 实验题目熟悉 Android Studio 开发工具操作熟悉 Android 基本 UI 开发，并进行 UI 基本设计¶ 二 实现内容实现一个 Android 应用，界面呈现如下效果：要求：1、该界面为应用启动后看到的第一个界面2、各控件的要求如下：要求只用一个 ConstraintLayout 实现整个布局；标题字体大小 20sp，与顶部距离 20dp，居中；图片与标题的间距为 20dp，居中；输入框整体距屏幕右边间距 20dp，上下两栏间距 20dp，内容（包括提示内容）如图所示，内容字体大小 18sp；学号对应的 EditText 只能输入数字，密码对应的 EditText 输入方式为密码；两个单选按钮整体居中，字体大小 18sp，间距 10dp，默认选中的按钮为第一个；两个按钮整体居中，与上方控件间距 20dp，按钮间的间距 10dp，文字大小 18sp。按钮背景框左 右边框与文字间距 10dp，上下边框与文字间距 5dp，圆角半径 10dp，背景色为#3F51B53、使用的布局和控件：ConstraintLayout、TextView、EditText、Button、ImageView、RadioGroup、 RadioButton¶ 三 课堂实验结果实验截图实验步骤以及关键代码1）文字信息，TextView模块。创建项目时，默认一个Activity以及一个activity_main.xml。xml文件中默认是一个TextView模块，文本text为hello world，只需将文本替换为“中山大学学生信息系统，再根据要求调整距离。id：模块标识layout_width：布局宽度，必须。wrap_content | match_parentlayout_height：布局高度，必须。wrap_content | match_parenttext：文本信息textSize：文字大小textColor：文字颜色layout_constraintXX_toXXOf：约束1234567891011&lt;TextView android:id="@+id/textView" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="中山大学学生信息系统" android:textSize="20sp" android:textColor="@color/colorBlack" android:layout_marginTop="20dp" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt;2）添加图片，ImageView模块。图片位置，将图片复制粘贴到res/drawable，最后通过@drawable/xxx来调用；图片大小，可以利用约束布局设置宽高的纵横比，把宽(layout_width)或者高(layout_height)设置为0dp，再根据另一个属性值和比例，计算当前属性值。layout_constraintDimensionRatio：设置图片比例12345678910&lt;ImageView android:id="@+id/imageView" android:src="@drawable/sysu" android:layout_width="150dp" android:layout_height="0dp" android:layout_marginTop="20dp" app:layout_constraintTop_toBottomOf="@id/textView" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintDimensionRatio="1:1" /&gt;3）下面信息，每一行都有两个元素，可以使用线性布局LinearLayout。输入模块，EditText，学号输入类型为number，密码输入类型为textPassswordhint：输入框提示inputType：输入类型1234567891011121314151617181920212223&lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/Button" app:layout_constraintTop_toBottomOf="@id/RadioGroup" android:layout_marginTop="20dp" android:gravity="center"&gt; &lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="登录" android:textColor="@color/colorWhite" android:background="@drawable/btn_selector" /&gt; &lt;Button android:id="@+id/button2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="注册" android:textColor="@color/colorWhite" android:background="@drawable/btn_selector" android:layout_marginLeft="10dp"/&gt;&lt;/LinearLayout&gt;4）单选按钮，RadioGroup模块。checked=&quot;true&quot;默认选择。orientation：定位。horizontal 水平 | vertical 垂直checked：默认选择。123456789101112131415161718192021222324&lt;RadioGroup android:id="@+id/RadioGroup" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="horizontal" android:layout_marginTop="20dp" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toBottomOf="@+id/password"&gt; &lt;RadioButton android:id="@+id/RB1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="学生" android:textSize="18sp" android:layout_marginRight="10dp" android:checked="true"/&gt; &lt;RadioButton android:id="@+id/RB2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="教职工" android:textSize="18sp" /&gt;&lt;/RadioGroup&gt;5）按钮模块Button。通过background设置按钮样式。background：背景颜色。1234567891011121314151617181920212223&lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/Button" app:layout_constraintTop_toBottomOf="@id/RadioGroup" android:layout_marginTop="20dp" android:gravity="center"&gt; &lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="登录" android:textColor="@color/colorWhite" android:background="@drawable/btn_selector" /&gt; &lt;Button android:id="@+id/button2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="注册" android:textColor="@color/colorWhite" android:background="@drawable/btn_selector" android:layout_marginLeft="10dp"/&gt;&lt;/LinearLayout&gt;res/drawable 文件夹下新建一个 Drawable resource file，再设定背景颜色（&lt;solid&gt;标签），弧形按钮（&lt;corners&gt;标签），文字与按钮框边界距离（&lt;padding&gt;标签）。文字颜色设为白色，颜色添加在res/values/colors.xml中添加。1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle" &gt; &lt;!--背景颜色--&gt; &lt;solid android:color="#003399 " /&gt; &lt;!--弧形按钮--&gt; &lt;corners android:radius="15dip" /&gt; &lt;!--文字边界--&gt; &lt;padding android:top="5dp" android:bottom="5dp" android:left="10dp" android:right="10dp"/&gt;&lt;/shape&gt;实验遇到困难以及解决思路1）图像约束布局不能按比例设置。刚开始设置width=150px，height=0px再根据1：1调整，但是发现height&gt;width，更改为width=0px与height=150px就是1：1的比例。原因：图像的底部没有约束其他控件，高度默认match_parent，而宽度是图像左右约束父组件边界，即居中显示，可以根据高度来调节宽度。或是将图像底部进行约束。2）参照实验文档提供的链接，设置按钮样式。新建.xml文件时，里面默认的标签是&lt;selector&gt;，而我们修改的是按钮的形状背景颜色，使用的标签应该是&lt;shape&gt;。改完按钮后，发现按钮字体是黑色，以为还是在.xml中改，改完之后发现不对，想起前面的文中都是直接添加android:textColor=&quot;@color/colorBlack&quot;的，所以就在values/colors中先添加colorWhite，再修改按钮字体。¶ 四 课后实验结果扩展：设置按钮UI，正常界面按钮颜色为深色，点击的时候变为浅色方法： 在res/drawable中新建两个xml，一个表示正常界面，另一个表示点击界面，两个.xml文件知识设置按钮背景颜色不同，其他样式一样，再新建一个.xml文件，使用selector标签，根据按钮的状态选择不同的按钮的样式12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@drawable/btn_shape" android:state_pressed="false"/&gt; &lt;item android:drawable="@drawable/btn_press" android:state_pressed="true"/&gt;&lt;/selector&gt;Github]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存管理]]></title>
    <url>%2Fc-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[¶ 1 内存分配栈 ：存放函数参数以及局部变量，在出作用域时，将自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但分配的内存容量有限。堆 ：new分配的内存块(包括数组，类实例等)，需delete手动释放。如果未释放，在整个程序结束后，OS会自动回收。自由存储区 ： malloc分配的内存块，需free手动释放。它和堆有些相似。全局/静态区 ： 全局变量(global)和静态变量(static)存于此处(在C语言中，全局变量又分为初始化的和未初始化的，C++不分)。常量存储区 ： 常量(const)存于此处，此存储区不可修改。¶ 2 堆和栈的区别举个栗子1void f() &#123; int* p=new int[5]; &#125;看到new，首先想到分配了一块堆内存，而指针p作为一个局部变量，分配的是一块栈内存。所以说，在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中。释放内存：delete []p管理方式栈是编译器自动管理的，堆需手动释放（程序员管理）空间大小在32位OS下，堆内存可达到4GB的空间，而栈就比较小(一般默认大小是1M，可以修改)碎片问题对于堆，频繁的new/delete会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低；对于栈，因为是先进后出，不会产生碎片生长方向栈向下生长，以降序分配内存地址；堆向上生长，以升序分配内在地址分配方式堆都是动态分配的，没有静态分配的堆。栈既可以静态分配也可以动态分配，静态分配是编译器完成的，比如局部变量的分配；动态分配由alloca函数进行分配，释放由编译器进行分配效率栈是系统提供的数据结构，计算机会在底层对栈提供支持，进栈/出栈都有专门的指令，这就决定了栈的效率比较高；堆则不然，它由C/C++函数库提供，机制复杂，堆的效率要比栈低得多¶ 3 malloc/free 与 new/deletemalloc与free是C/C语言的标准库函数，new/delete是C的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。¶ 4 内存错误内存分配未成功使用之前检查指针是否为NULL内存分配成功，未初始化记得初始化内存溢出循环判断过程中，不要多1少1没有释放内存使用new/malloc，记得delete/free释放内存，指针记得设为NULL，防止产生“野指针”¶ 参考链接C/C++内存管理详解alloca—可以在栈中动态分配内存的函数]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++面向对象编程]]></title>
    <url>%2Fc-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[The content is unfinished ! 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]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础]]></title>
    <url>%2Fc-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[¶ 1 基本类型1cout &lt;&lt; sizeof(数据类型) &lt;&lt; endl;类型字节short2int4long4long long8bool1char1float4double8¶ 2 换行符‘\n’: 一个字符，表示回车，不会立即刷新缓冲区“\n”: 一个字符串，表示同上endl: 一个流操作子，实际表示std::endl，输出一个换行符，并立即刷新缓冲区1std::cout &lt;&lt; std::endl;相当于：1std::cout &lt;&lt; "\n" &lt;&lt; std::flush;¶ 3 typedef别名123// typedef type newName;typedef int feet;feet distance; // 合法¶ 4 enum枚举123456enum 枚举名&#123; 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数]&#125; 枚举变量;如果枚举没有初始化, 即省掉&quot;=整型常数&quot;时, 则从第一个标识符开始。例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。12enum color &#123; red, green, blue &#125; c;c = blue;默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。1enum color &#123; red, green=5, blue &#125;;在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。¶ 5 左值和右值左值（lvalue）：指向内存位置的表达式被称为左值表达式。左值可以出现在赋值号的左边或右边。右值（rvalue）：指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：12int g = 20;int h = g;但是下面这个就不是一个有效的语句，会生成编译时错误：110 = 20;¶ 6 流操作符流操作符描述left输出左对齐，必要时在右边填充right输出右对齐，必要时在左边填充internal符号左对齐，数值右对齐dec十进制表示oct八进制表示，C语言printf(&quot;%o\n&quot;, num)hex十六进制表示，C语言printf(&quot;%x\n&quot;, num)showbase显示基数（0开头为8进制，0x为16进制）showpoint浮点数必须显示小数点，例如 9.0 （如不使用，输出为9）showpos正数前面显示加号（+）setw(n)设置输出宽度setprecision(n)设置浮点数精度小数保留位数123456789double f = 1.9;cout &lt;&lt; setprecision(5) &lt;&lt; f &lt;&lt; endl; // 保留5位有效数字cout &lt;&lt; ios::fixed &lt;&lt; setprecision(5) &lt;&lt; f &lt;&lt; endl; // 保留小数点后5位cout &lt;&lt; ios::scientific &lt;&lt; f &lt;&lt; endl; // 科学计数法，用e表示// C语言printf("%a.blf\n", f); // a为输出宽度，b为小数保留位数// 自定义printf("%*.*lf\n", a, b, f);内容填充指定对齐域的填充字符，如果没有字符被指定，则使用空格符填充。（默认左填充）12345char c = 'a';cout &lt;&lt; left &lt;&lt; setw(5) &lt;&lt; setfill('*') &lt;&lt; c &lt;&lt; endl; // a**** // 或者cout.fill('*')；cout &lt;&lt; right &lt;&lt; setw(5) &lt;&lt; c &lt;&lt; endl; // ****a¶ 7 其他运算符运算符描述sizeof运算符返回变量的大小。例如，int a; sizeof(a) 将返回 4。Condition ? X : Y条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。Cast强制转换运算符。把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2&amp;指针运算符。返回变量的地址。例如 &amp;a; 将给出变量的实际地址。*指针运算符。指向一个变量。例如*var; 将指向变量 var。¶ 8 类型转换头文件&lt;stdlib.c&gt;itoa ：int $$\rightarrow$$ string1itoa(int, char[], base);atoi ：string $$\rightarrow$$ int1int a = atoi(char[]); // atoi(string.c_str());¶ 9 取整ceil：上取整12double f = 9.3;cout &lt;&lt; ceil(f) &lt;&lt; endl; // 10floor：下取整1234// 浮点数运算有可能存在误差cout &lt;&lt; floor(f+0.5) &lt;&lt; endl; // 9 // int 默认下取整int a = f; // 9¶ 10 &lt;ctype.h&gt;函数描述isapha判断字符是否是字母isdigit判断是否是数字islower判断字符是否是小写字母isupper判断字符是否是大写字母isalnum判断字符是否是数字/字母ispunct判断是否是标点符号isspace判断是否是空格、回车\n、换页\f、水平制表\t、垂直制表\vtolower转换为小写字母toupper转换为大写字母]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正方系统抢课程序——Python]]></title>
    <url>%2F%E6%AD%A3%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%8A%A2%E8%AF%BE%E7%A8%8B%E5%BA%8F%E2%80%94%E2%80%94Python%2F</url>
    <content type="text"><![CDATA[注：该脚本应朋友要求写的，不是本校的教务系统。抢课脚本，其实就是模拟选课的过程。所以，首先要了解HTTP协议，我们输入教务系统为什么会有一个界面显示，这个界面就是一个html，简单来说，浏览器是一个客户端，教务系统在另一端的服务器上，输入教务系统的地址，就是向服务器发送一个请求，当中会有“三次握手”先建立连接，接着发送一个请求得到服务器响应，服务器向客户端传送一个html文件，客户端解析再显示出来。¶ 1 选课流程通过浏览器开发者工具（F12）观察选课流程的请求与响应。¶ 1.1 登录登录提交表单的地址是http://jwc.gdlgxy.com/default2.aspxRequest Headers请求头部中，很多信息都是默认的，Cookie是网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据，因为不同浏览器以及生命周期会发生变化，需要记录Cookie的值。Form Data表单中包含了重要的信息：状态码、学号、密码、验证码。cookie、状态码（VIEWSTATE）、验证码（CheckCode），在输入教务地址的时候就可以获取。以下是输入教务系统地址，得到的响应文件：¶ 1.2 选课第一步，选课类型第二步，筛选课程第三步，选择课程，提交选课过时了，没来得及保存图片在页面上的点击，都是一次请求，每一次的请求状态码VIEWSTATE可能不一致，下一步请求提交的数据中的状态码可以从上一步请求得到的响应文件中查找。如何获取上面的信息？选课类型：代码是固定的，公共选修课N121203，体育选课N121205，院系选修课N121207学生姓名编码输入姓名，再进行URL编码在登录获取的响应中查找状态码在从上一次的响应文件中查找编码问题输入中文，例如：'有'.encode('gbk')通过网页工具（站长工具）编码¶ 2 模拟抢课通过浏览器的开发者工具（F12），得到每一次的请求信息（Request Headers和Form Data），模拟登陆、模拟选课就是向教务系统的服务器，发送相同的请求，得到我们需要的响应，即选到心仪的课程。¶ 2.1 登录¶ 2.1.1 初始化12345# self.host = input('输入地址：')self.host = 'xxx' # 教务系统地址 / IPself.baseUrl = 'http://' + self.hostself.checkCodeUrl = self.baseUrl + '/CheckCode.aspx' # 验证码地址 self.loginUrl = self.baseUrl + '/default2.aspx' # 提交表单链接¶ 2.1.2 保存cookie123456789101112131415self.cookie = http.cookiejar.CookieJar() # 声明一个CookieJar对象实例来保存cookie，在打开网页的时候保存cookieself.handler = urllib.request.HTTPCookieProcessor(self.cookie) # 创建cookie处理器self.opener = urllib.request.build_opener(self.handler, urllib.request.HTTPHandler) # 通过handler来构建opener# 加入默认的首部行self.opener.addheaders = [ ('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'), ('Accept-Encoding', 'gzip, deflate'), ('Accept-Language', 'zh-CN,zh;q=0.9'), ('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36'), ('Connection', 'keep-alive'), ('Content-Type', 'application/x-www-form-urlencoded'), ('Cache-Control', 'max-age=0'), ('Upgrade-Insecure-Requests', '1')]# 通过urlopen()来使用openerurllib.request.install_opener(self.opener)¶ 2.1.3 获取验证码1234567891011121314def getCheckCode(self): path = 'config/code.gif' # 抓取验证码图片保存到本地 code = '' while code is '': fl = open(path, 'wb') try: # 三秒防刷 fl.write(urllib.request.urlopen(self.checkCodeUrl, timeout=3).read()) except: print('the code.aspx has not response') continue finally: fl.close() code = input("验证码(回车更新)：") # must wait for fl.close()return code¶ 2.1.4 获取状态码1234567891011121314def getViewstate1(self): # print("---Viewstate1---") viewstate = None while viewstate is None: try: html = urllib.request.urlopen(self.loginUrl, timeout=3).read().decode('gbk') soup = BeautifulSoup(html, 'html.parser') # 响应得到的html文件 soup = soup.find_all(attrs=&#123;'name': '__VIEWSTATE'&#125;)[0] # 在html文件中查找状态吗 viewstate = soup.get('value') except: print('the login.aspx has not response') continue # print("viewstate1：", viewstate)return viewstate¶ 2.1.5 提交表单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566def login(self): # 输入学号密码 xh = input('输入学号：') pw = input('输入密码：') # 输入验证码 code = self.getCheckCode() # 课程归属（默认公共选修课） lx = 'N121203' self.refUrl = self.baseUrl + '/xs_main.aspx?xh=' + xh # 登录教务系统 headers = &#123; 'Host': self.host, 'Origin': self.baseUrl, 'Referer': self.baseUrl + '/' &#125; # Request Headers postdata = urllib.parse.urlencode(&#123; '__VIEWSTATE': self.getViewstate1(), 'txtUserName': xh, 'TextBox2': pw, 'txtSecretCode': code, 'RadioButtonList1': '学生'.encode('gbk'), # use gbk 'Button1': '', 'lbLanguage': '', 'hidPdrs': '', 'hidsc': '' &#125;).encode('utf-8') # Form Data post = urllib.request.Request(self.loginUrl, postdata, headers) try: page = urllib.request.urlopen(post).read().decode('gbk') # 查找错误信息（验证码/密码出错） error = re.findall('alert.+?错误！！\'\)', page) if error: print(error[0]) self.login() else: # 登录信息正确，直接进入到选课界面 # 课程归属 n = input('选择课程类型：1.公共选修课 2.体育选课 3.院系选修课\n') if n == '1': lx = 'N121203' elif n == '2': lx = 'N121205' elif n == '3': lx = 'N121208' else: print('暂不支持该选课类型') exit(0) get = urllib.request.Request(self.refUrl, headers=headers) try: f = urllib.request.urlopen(get) page = f.read().decode('gbk') # 查找学生姓名，也可以通过输入，不过打字有可能比较慢 info = re.findall(r'xf_xsqxxxk.+?gnmkdm=', page) assert info is not None # 正则表达式，查找中文字符 words = re.findall(u"[\u4e00-\u9fa5]+", info[0]) assert words is not None info = info[0].replace(words[0], parse.quote(words[0].encode('gbk'))) # 通过获取的信息，组成选课页面的链接 self.chooseUrl = self.baseUrl + '/' + info + lx except: print('get chooseUrl failed.') except: print('login has no respone.')¶ 2.2 选课¶ 2.2.1 最后一步12345678910111213141516171819202122232425262728293031323334353637383940414243444546def submit(self): # 选课信息（定位课程） self.course = input("输入课程：") self.date = input("输入时间：") viewstate3 = self.getViewstate3() # 获取状态码 postdata = urllib.parse.urlencode(&#123; '__EVENTTARGET': '', '__EVENTARGUMENT': '', '__VIEWSTATE': viewstate3, 'ddl_kcxz': '', 'ddl_ywyl': '有'.encode('gbk'), 'ddl_kcgs': '', 'ddl_xqbs': 2, 'ddl_sksj': self.date.encode('gbk'), 'TextBox1': self.course.encode('gbk'), 'kcmcGrid:_ctl2:xk': 'on', 'kcmcGrid:_ctl2:jcnr': '|||', 'dpkcmcGrid:txtChoosePage': 1, 'dpkcmcGrid:txtPageSize': 15, 'Button1': ' 提交 '.encode('gbk'), 'dpDataGrid2:txtChoosePage': 1, 'dpDataGrid2:txtPageSize': 150 &#125;).encode('utf-8') # Form Data headers = &#123; 'Host': self.host, 'Origin': self.baseUrl, 'Referer': self.chooseUrl &#125; # Request Headers while True: req = urllib.request.Request(self.chooseUrl, postdata, headers) try: f = urllib.request.urlopen(req, timeout=3) html = f.read().decode('gbk') # 检查是否选课成功，响应文件html中出现"已选课程……xxx"的信息 pat = '&lt;legend&gt;已选课程&lt;/legend&gt;&lt;table.+?' + self.course + '.+?&lt;/table&gt;' pattern = re.compile(pat, re.S) length = len(re.findall(pattern, html)) if (length == 1): # 如果选课成功，则退出，否则继续抢课 print('选课成功') break except: print('submit has no response') continue¶ 2.2.2 状态码最后一步选课的状态码是从上一次筛选条件的请求得到的响应文件中获取的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061def getViewstate3(self): # print("---viewstate3---") headers = &#123; 'Host': self.host, 'Origin': self.baseUrl, 'Referer': self.chooseUrl, &#125; viewstate2 = self.getViewstate2() # 状态码2是从选课类型请求得到的响应中获取 postdata = urllib.parse.urlencode(&#123; '__EVENTTARGET': '', '__EVENTARGUMENT': '', '__VIEWSTATE': viewstate2, 'ddl_kcxz': '', 'ddl_ywyl': '有'.encode('gbk'), 'ddl_kcgs': '', 'ddl_xqbs': 2, 'ddl_sksj': self.date.encode('gbk'), 'TextBox1': self.course.encode('gbk'), 'Button2': '确定'.encode('gbk'), 'kcmcGrid:_ctl2:jcnr': '|||', 'kcmcGrid:_ctl3:jcnr': '|||', 'kcmcGrid:_ctl4:jcnr': '|||', 'kcmcGrid:_ctl5:jcnr': '|||', 'kcmcGrid:_ctl6:jcnr': '|||', 'kcmcGrid:_ctl7:jcnr': '|||', 'kcmcGrid:_ctl8:jcnr': '|||', 'kcmcGrid:_ctl9:jcnr': '|||', 'kcmcGrid:_ctl10:jcnr': '|||', 'kcmcGrid:_ctl11:jcnr': '|||', 'kcmcGrid:_ctl12:jcnr': '|||', 'kcmcGrid:_ctl13:jcnr': '|||', 'kcmcGrid:_ctl14:jcnr': '|||', 'kcmcGrid:_ctl15:jcnr': '|||', 'kcmcGrid:_ctl16:jcnr': '|||', 'dpkcmcGrid:txtChoosePage': 1, 'dpkcmcGrid:txtPageSize': 15, 'dpDataGrid2:txtChoosePage': 1, 'dpDataGrid2:txtPageSize': 150 &#125;).encode('utf-8') # Form Data req = urllib.request.Request( url=self.chooseUrl, data=postdata, headers=headers) # Request Headers viewstate3 = None while viewstate3 is None: try: f = urllib.request.urlopen(req, timeout=3) html = f.read().decode('gbk') soup = BeautifulSoup(html, 'html.parser') try: soup = soup.find_all(attrs=&#123;'name': '__VIEWSTATE'&#125;)[0] viewstate3 = soup.get('value') except: print('get response but cant get VIEWSTATE') continue except: print('get available course has no response') continue return viewstate3¶ 2.3 选课结果¶ 参考链接C++网络编程之使用Winsock2实现教务系统自动抢课程序python爬虫之urllib2登录并抓取HTML页面]]></content>
      <categories>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[The content is unfinished ! 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]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐藏未完成编辑的文章]]></title>
    <url>%2F%E9%9A%90%E8%97%8F%E6%9C%AA%E5%AE%8C%E6%88%90%E7%BC%96%E8%BE%91%E7%9A%84%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[一般都是博客编辑完成，再发布上去，但有时候可能是同时编辑多篇文章，有些编辑了一半，提交上去，只能看到半成品，所以想了个办法把半成品隐藏了。这个修改是基于hexo-blog-encrypt插件的，即将博文加密，只显示“The content is unfinished！”。¶ 1 修改模板文件/scaffolds/post.md，添加1done: false这样每次创建一遍新的博文，front-matter都会添加上面语句，标志未完成编辑，如果编辑完成，只需把false改为true，再发布上去。¶ 2 修改插件文件/node_modules/hexo-blog-encrypt/lib/中添加一个ccs文件display.css，拷贝style.css，修改语句123.input-container input &#123; display: none; // 隐藏输入&#125;文件/node_modules/hexo-blog-encrypt/index.js，修改如下：12345678910111213141516171819202122232425262728var flag = false; // 标志hexo.extend.filter.register("after_post_render", function (data) &#123; // 添加 if ('done' in data &amp;&amp; !data.done) &#123; data.password = "123"; //加密密码 data.abstract = '&lt;img src="http://oxv1k8kvi.bkt.clouddn.com/18-4-23/56493546.jpg"&gt;'; // 前文显示 data.message = "The content is unfinished !"; if (!('template' in data &amp;&amp; data.template)) &#123; data.template = hexo.config.encrypt.default_template; &#125; data.template = '&lt;link href="' + hexo.config.root + 'display.css" rel="stylesheet" type="text/css"&gt;' + data.template; flag = true; &#125; // 修改 if ('password' in data &amp;&amp; data.password) &#123; if (! ('done' in data &amp;&amp; !data.done)) data.content = '&lt;link href="' + hexo.config.root + 'style.css" rel="stylesheet" type="text/css"&gt;' + data.content; &#125;&#125;);hexo.on('exit', function() &#123; // 将display.css添加到插件根目录（hexo.config.root）下 var cssFile2 = pathFn.join(pathFn.join(pathFn.join(pathFn.join(hexo.base_dir, 'node_modules'), 'hexo-blog-encrypt'), 'lib'), 'display.css'); fs.readFile(cssFile2).then(function(content) &#123; fs.copyFile(cssFile2, pathFn.join(hexo.public_dir, 'display.css')); &#125;);&#125;);]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[¶ 1 概述HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。特点：简单快速客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。灵活HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。无状态服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。假如某个特定客户在短短几秒内两次请求同一个对象，服务器并不会¶ 2 URLHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。完全格式基本格式URI、URL和URN的区别URI ：Uniform Resource Identifier，统一资源标识符，URL、URN是URI的子集；URL：Uniform Resource Locator，统一资源定位符；URN：Uniform Resource Name，统一资源名称。Web上地址的基本形式是URI，它代表统一资源标识符。有两种形式：URL：目前URI的最普遍形式。URN：URL的一种更新形式，不依赖于位置，并且有可能减少失效连接的个数。但是其流行还需假以时日，因为它需要更精密软件的支持。URI有绝对和相对之分：绝对的URI，如http://www.danboard.me/HTTP协议/img.png相对的URI，如HTTP协议/img.png¶ 3 非持续/持续连接非持续连接一个WEB站点每天可能要接收到上百万的用户请求，为了提高系统的效率，HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性能。问题 :第一，对于每个连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量，造成严重负担；第二，每一个传输对象都要经受两倍RTT的交付时延，严重影响效率。持续连接HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序 依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。可以一个接一个地发出对对象的请求，而不必等待未决请求的响应（流水线）。一般，如果一条连接经过一定的时间间隔仍未被使用，HTTP服务器就关闭该连接。¶ 4 报文格式¶ 4.1 请求Request组成：请求行、请求头部（首部行）、空行、请求数据请求方法GET：请求获取RequestURL所标识的资源，最常用的方法POST：在RequestURL所标识的资源后附加新的数据，可以导致新资源的产生和已有资源的更新HEAD：请求获取RequestURL所标识的资源的响应消息报头，没有响应体PUT：请求服务器存储一个资源，并用RequestURL作为其标识DELETE：请求服务器删除RequestURL所标识的资源GET与POST比较例子12345GET /somedir/page.html HTPP/1.1Host: www.someschool.eduConnection: Keep-aliveUser-agent: Mozilla/5.0Accept-language: fr1234567POST /somedir/page.html HTPP/1.1Host: www.someschool.eduConnection: Keep-aliveUser-agent: Mozilla/5.0Accept-language: frusername=STUDENT&amp;password=123456¶ 4.2 响应Response组成：状态行、消息报头、空行、响应正文例子123HTTP/1.1 200 OKDate: Fri, 22 May 2009 06:07:21 GMTContent-Type: text/html; charset=UTF-8状态码1xx：指示信息，表示请求已接收，继续处理2xx：成功，表示请求已被成功接收、理解、接受3xx：重定向，要完成请求必须进行更进一步的操作4xx：客户端错误，请求有语法错误或请求无法实现5xx：服务器端错误，服务器未能实现合法的请求¶ 5 工作原理¶ 5.1 客户端连接到Web服务器一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，[http://www.oakcms.cn](http://www.oakcms.cn./¶ 5.2 发送HTTP请求通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。¶ 5.3 服务器接受请求并返回HTTP响应Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。¶ 5.4 释放连接TCP连接若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection 模式为keep-alive，则该连接会保持一段时间，在该时间内可以继续接收请求。¶ 5.5 客户端浏览器解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。¶ 参考链接HTTP 1.1与HTTP 1.0的比较关于HTTP协议，一篇就够了]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/UDP]]></title>
    <url>%2FTCP-UDP%2F</url>
    <content type="text"><![CDATA[TCP （Transmission Control Protocol，传输控制协议）与 UDP （User Data Protocol，用户数据包协议）是Internet运输层在应用程序端点之间传送应用层报文的两种协议。运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信。¶ TCP协议¶ 1 全双工如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可以从进程B流向进程A的同时，也从进程A流向进程B。¶ 2 点对点单个发送方与单个接收方之间的连接。¶ 3 面向连接三次握手（建立连接）客户端发送：SYN = 1, SEQ = X, 端口号服务器回复：SYN = 1, ACK = X + 1, SEQ = Y客户端发送：ACK = Y + 1, SEQ = X + 1确认应答信号ACK = 收到的SEQ + 1。连接建立中，同步信号SYN始终为1。连接建立后，同步信号SYN = 0。为什么要三次握手？三次握手是保证双方互相明确对方能收发信息的最低值。三次握手 ：“喂，你听得到吗？”“我听得到呀，你听得到我吗？”“我能听到你，今天balabala……”两次握手：“喂，你听得到吗？”“我听得到呀”“喂喂，你听得到吗？”“草，我听得到呀！！！！”“你TM能不能听到我讲话啊！！喂！”“……”四次握手：“喂，你听得到吗？”“我听得到呀，你听得到我吗？”“我能听到你，你能听到我吗？”“……不想跟傻逼说话”——来自知乎​四次挥手（断开连接）A向B提出停止连接请求，FIN = 1B收到，ACK = 1B向A提出停止连接请求，FIN = 1A收到，ACK = 1为什么四次握手？四次挥手：“喂，我不说了。”“我知道了。等下，上一句还没说完。Balabala……””好了，说完了，我也不说了。””我知道了。”¶ 4 报文段结构源端口和目的端口 ：各占 2 字节。端口是传输层与应用层的服务接口，传输层的复用和分用功能都要通过端口才能实现序号 / 确认号：占 4 字节。这些字段被TCP发送方和接收方用来实现可靠数据传输服务。数据偏移（首部长度）：占 4 位。它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位(以 4 字节为计算单位)保留：占 6 位。保留为今后使用，但目前应置为 0标志字段URG ：当 URG=1 时,表明紧急指针字段有效.它告诉系统此报文段中有紧急数据,应尽快传送(相当于高优先级的数据)ACK ：只有当 ACK=1 时确认号字段才有效；当 ACK=0 时,确认号无效PSH ：接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付RST ：当 RST=1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接SYN ：同步 SYN = 1 表示这是一个连接请求或连接接受报文FIN ：用来释放一个连接，FIN=1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接窗口 ：占2字节。用于流量控制。检验和 ：占 2 字节。检验和字段检验的范围包括首部和数据这两部分，在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部紧急指针 ：占 16 位。指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）选项：长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节.” [MSS(Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度.数据字段加上 TCP 首部才等于整个的 TCP 报文段]填充 ：这是为了使整个首部长度是 4 字节的整数倍¶ 5 可靠数据传输确认丢失和确认迟到超时重传TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。¶ 6 拥塞控制拥塞窗口含义:拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，如再考虑到接收方的接收能力，则发送窗口还可能小于拥塞窗口。发送方控制拥塞窗口的原则:只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去.但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。慢启动在主机刚刚开始发送报文段时可先设置拥塞窗口 cwnd = 1，即设置为一个最大报文段 MSS 的数值在每收到一个对新的报文段的确认后,将拥塞窗口加 1，即增加一个 MSS 的数值使用慢开始算法后，每经过一个传输轮次(往返时间 RTT)，拥塞窗口 cwnd 就加倍拥塞避免拥塞避免状态：cwnd的值大约是上次遇到拥塞是的值的一半线性增长，每个RTT只将cwnd的值增加一个MSS快速恢复Reno：当出现丢包事件时，cwmd值为原来的一半，然后线性增长。Tahoe：当出现丢包事件时，ssthresh的值设置为cwmd值的一半，cwnd的值被设置为1个MSS，然后继续慢启动、拥塞避免。拥塞窗口的大小取决于网络的拥塞程度,并且动态地在变化.发送方让自己的发送窗口等于拥塞窗口.如再考虑到接收方的接收能力,则发送窗口还可能小于拥塞窗口发送方控制拥塞窗口的原则:只要网络没有出现拥塞,拥塞窗口就再增大一些,以便把更多的分组发送出去.但只要网络出现拥塞,拥塞窗口就减小一些,以减少注入到网络中的分组数¶ 7 优缺点优点可靠、稳定缺点效率低、已被攻击（DOS）¶ UDP协议¶ 1 面向无连接¶ 2 优缺点优点传输速率快（适合音、视频传输，容忍丢失）缺点不可靠、不稳定（没有拥塞控制）​¶ 区别TCPUDP面向有连接的通信服务面向无连接的通信服务四元组（源IP+端口/目的IP+端口）二元组（目的IP+端口）提供可靠的通信传输不可靠，会丢包保证数据顺序可能乱序数据无边界数据有边界传输速度慢传输速度快面向字节流面向报文一对一可以一对一，或一对多报头至少20字节报头8字节有流量控制，拥塞控制没有¶ 参考链接TCP与UDPTCP详解]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[右键菜单的新建项中添加办公程序]]></title>
    <url>%2F%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E7%9A%84%E6%96%B0%E5%BB%BA%E9%A1%B9%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%8A%9E%E5%85%AC%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[平时打开办公软件的习惯时，直接右键 → 新建 → Word/Excel/PowerPoint等等，桌面上没有办公软件的图标，显得简洁一点。由于，平时一些实验报告要用到markdown来写，所以想到像word这些办公软件一样直接在某个目录下新建，修改名称就可以了，编写的时候直接ctrl+s保存。习惯因人而异，不喜勿喷！！！打开注册表快捷键Win+R，输入regedit找到文件后缀名HKEY_CLASSES_ROOT→ .md右键 → 新建 → 项，命名为ShellNew进入shellNew，右键 → 新建 → 字符串值，命名为NullFile，即每次打开markdown，都会创建一个空文档。使注册表生效第一种：重启第二种：任务管理器，找到explorer.exe，结束该进程，再启动（运行新任务+explorer.exe）​效果]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>windows</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组解析]]></title>
    <url>%2F%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[¶ 1 数组¶ 1.1 定义数组是一组具有相同类型的、连续的内存区域。要引用数组中的一个特定区域或元素，需要通过指定数组名和该元素在数组中的位置编号。¶ 1.2 声明12int a[5]; // 大小为5 int b[]; // Error¶ 1.3 初始化1234int a[] = &#123;1, 2, 3, 4, 5&#125;; // 初始化，大小为5int a[5] = &#123;1, 2, 3&#125;; // 初始化，1，2，3，0，0int a[5] = &#123;1, 2, 3, 4, 5, 6&#125;; // Error, 数组越界int b[] = a; // Error, 不能直接复制注意：字符串数组，数组大小要比字符数大1，因为字符串数组后面还有一个默认的空字符’\0’1char c[6] = "Hello";¶ 2 指针¶ 2.1 定义在C++中，数组和指针是密切相关的，两者几乎可以交换使用。可以认为一个数组名就是一个常量指针。¶ 2.2 使用12345int b[5];int *bptr;// 数组名不带下标，是一个指向数组第一个元素的指针bptr = b; // bptr = &amp; b[0];// * (bptr+3) 等价于 b[3]¶ 2.3 数组指针指向数组的指针。123456int a[2][2] = &#123;1, 2, 3, 4&#125;; // 二维数组int (*p)[2] = a;// a 是一个数组名，指向一维数组的指针，值 &amp;a[0][0]， sizeof(a) = 16// a[0] 是一维数组名，指向整型的指针，值 &amp;a[0][0]// a[1] 是一维数组名，指向整型的指针，值 &amp;a[1][0]// p 是一个数组指针变量，值 &amp;a[0][0], sizeof(p) = 4¶ 2.4 指针数组存放指针的数组。常见于构成基于指针的字符串的数组。123char *p[2] = &#123;"Hello", "World"&#125;;// p，指向char数组的指针，值 &amp;p[0]，sizeof(p) = 16// p[0] 是一个char数组，值"Hello"¶ 3 vector¶ 3.1 定义一个封装了动态大小数组的顺序容器（Sequence Container），能够存放任意类型的动态数组。效率：数组&gt;vector，原因是vector的插入删除要消耗更多时间。¶ 3.2 初始化12345vector&lt;int&gt; a(3); // 大小为3vector&lt;int&gt; b(3, 0); // 大小为3，初始化为0vector&lt;int&gt; c = &#123;1, 2, 3&#125;; // 大小为3，初始化为1，2，3，等号可以省略vector&lt;int&gt; d = c; // 直接复制vector&lt;int&gt; e(c); // 直接复制¶ 3.3 函数¶ 3.3.1 构造函数vector():创建一个空vectorvector(int n):创建一个vector，大小为nvector(int n, const t&amp; t):创建一个vector，大小为n，且值均为tvector(const vector&amp; a):复制构造函数vector(a.begin(), a.end()):复制[begin,end)区间内数组a的元素到vector中¶ 3.3.2 插入函数a.push_back(const T&amp; x):尾部插入元素a.insert(iterator it, const T&amp; x):指定位置插入¶ 3.3.3 删除函数a.erase(iterator it):删除向量中迭代器指向元素a.erase(iterator first, iterator last):删除向量中[first,last)中元素a.pop_back():删除向量中最后一个元素a.clear():清空向量中所有元素¶ 3.3.4 其他函数bool empty() const:判断向量是否为空，若为空，则向量中无元素int size() const:返回向量中元素的个数¶ 4 array¶ 4.1 定义c++11中给数组提供的更加安全的访问方式，是一种容器类型，支持一系列容器操作。效率跟数组相近。¶ 4.2 初始化123array&lt;类型, 大小&gt; a; array&lt;int, 3&gt; a = &#123;1, 2, 3&#125;;array&lt;int, 3&gt; b = a; // 大小一致¶ 5 总结数组vectorarray备注内存栈（静态）堆（动态）栈（静态）效率高低高索引a[i]a[i] / a.at(i)a[i]i从0开始a.at(i)检查是否越界NYYarray&lt;int, 2&gt;a= { 1,2, };cout &lt;&lt; a.at(-1) &lt;&lt; endl; // Error复制NY，类型相同Y，类型和大小相同大小sizeof(a)/size(类型)，固定a.size()，可变a.size()，固定includeN&lt;vector&gt;&lt;array&gt;初始化赋值YYY插入NYN删除NYN访问数组范围外的数据YYY例如a[-40]或者a[100]]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法总结和归纳]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%92%8C%E5%BD%92%E7%BA%B3%2F</url>
    <content type="text"><![CDATA[非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。¶ 1 冒泡排序交换排序，最简单的一种排序算法。从第一个元素开始，与之后的元素逐一比较，如果后者小于前者，则交换位置，从而找到最大的元素。12345678910void bubble(int* a, int n)&#123; for(int i=0; i&lt;n-1; i++) &#123; for (int j=0; j&lt;n-1-i; j++) &#123; if(a[j] &gt; a[j+1]) &#123; swap(a[i], a[j]); &#125; &#125; &#125;&#125;¶ 2 快速排序交换排序，是冒泡排序的一种改进算法。通过一次排序将待排数据分割成两部分，前一部分数据均比后一部分数据小，则可分别对这两部分的数据继续排序，从而达到整体有序。123456789101112131415161718192021222324int Partition(int* a, int low, int high)&#123; int i = low, j = high; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; a[i] &lt;= a[j]) j --; // 右侧扫描 if(i &lt; j) &#123; swap(a[i], a[j]); i ++; &#125; while(i &lt; j &amp;&amp; a[i] &lt;= a[j]) i ++; // 左侧扫描 if(i &lt; j) &#123; swap(a[i], a[j]); j --; &#125; &#125; return i;&#125;void Quick(int* a, int low, int high)&#123; if(low &lt; high) &#123; int pivot = Partition(a, low, high); // 一次划分 Quick(a, low, pivot-1); // 前一个子序列排序 Quick(a, pivot+1, high); // 后一个子序列排序 &#125;&#125;¶ 3 插入排序简单排序算法。默认第一个元素已经排序好，将下一个元素按大小插入已排好序的列表，重复这样的操作，知道最后一个元素插入。12345678910111213void Insert(int* a, int n)&#123; for(int i=1; i&lt;n-1; i++) &#123; int tmp = a[i]; // 记录待排记录 int j = i - 1; // 与前面排好的序列记录依次比较 while(j &gt;= 0 &amp;&amp; a[j] &gt; tmp) &#123; a[j+1] = a[j]; j --; &#125; a[j+1] = tmp; &#125;&#125;¶ 4 希尔排序插入排序的改进，也叫“缩小增量排序”。先将整个待排序列分割成若干个子序列，分别进行插入排序，逐渐缩小划分的间隔，直到最后，间隔为1，对全体进行一次插入排序，得到一个有序序列。1234567891011121314void Shell(int* a, int n)&#123; for(int d=n/2; d&gt;=1; d=d/2) &#123; // 初始间隔为序列大小的一半 for(int i=d; i&lt;n; i++) &#123; int tmp = a[i]; // 记录待排记录 int j = i - d; while(j&gt;=0 &amp;&amp; a[j]&gt;tmp) &#123; // 进行插入排序 a[j+d] = a[j]; j -= d; &#125; a[j+d] = tmp; &#125; &#125;&#125;¶ 5 选择排序简单的排序算法。每次在未排序序列中找到最小元素，存放到已排序列。12345678910void Select(int* a, int n)&#123; for(int i=0; i&lt;n-1; i++) &#123; for (int j=i+1; j&lt;n; j++) &#123; if(a[i] &gt; a[j]) &#123; swap(a[i], a[j]); &#125; &#125; &#125;&#125;¶ 6 堆排序堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，使得在当前无序区中选取最大（或最小）关键字的记录变得简单。123456789101112131415161718192021222324252627void Adjust(int* a, int p, int n) //堆调整&#123; for(int i=2*p+1; i&lt;n; i=i*2+1)&#123; //如果右边值大于左边值，指向右边 if(i+1 &lt; n &amp;&amp; a[i] &lt; a[i+1]) i ++; //如果子节点大于父节点，将子节点值赋给父节点,并以新的子节点作为父节点 if(a[p] &gt;= a[i]) break; else &#123; swap(a[p], a[i]); p = i; &#125; &#125;&#125; void Heap(int* a, int n)&#123; // 构建大顶堆 for(int i=n/2-1; i&gt;=0; i--) &#123; Adjust(a, i, n); &#125; // 交换堆顶与末尾元素，重新调整堆 for(int i=n-1; i&gt;0; i--) &#123; swap(a[0], a[i]); Adjust(a, 0, i); &#125;&#125;¶ 7 归并排序分治法，将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。1234567891011121314151617181920212223242526272829void Merge(int sourceArr[], int tempArr[], int startIndex, int midIndex, int endIndex)&#123; int i = startIndex, j = midIndex+1, k = startIndex; while(i!=midIndex+1 &amp;&amp; j!=endIndex+1) &#123; if(sourceArr[i] &gt; sourceArr[j]) tempArr[k++] = sourceArr[j++]; else tempArr[k++] = sourceArr[i++]; &#125; while(i != midIndex+1) tempArr[k++] = sourceArr[i++]; while(j != endIndex+1) tempArr[k++] = sourceArr[j++]; for(i=startIndex; i&lt;=endIndex; i++) sourceArr[i] = tempArr[i];&#125; void MergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex)&#123; int midIndex; if(startIndex &lt; endIndex) &#123; midIndex = (startIndex + endIndex) / 2; // 递归，二路归并 MergeSort(sourceArr, tempArr, startIndex, midIndex); MergeSort(sourceArr, tempArr, midIndex+1, endIndex); // 内部排序 Merge(sourceArr, tempArr, startIndex, midIndex, endIndex); &#125;&#125;¶ 8 计数排序计数排序是一个非基于比较的排序算法，它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(nlogn)的时候其效率反而不如基于比较的排序。思路：根据元素大小作为另一个数组的序号，再统计该元素的个数，最后按序输出。1234567891011121314# define MAX 1000int bucket[MAX];void CountSort(int arr[], int n) &#123; for (int i=0; i&lt;n; i++) &#123; bucket[arr[i]]++; &#125; int k = 0; for (int j=0; j&lt;MAX; j++) &#123; while(bucket[j] &gt; 0) &#123; arr[k++] = j; bucket[j] --; &#125; &#125;&#125;¶ 9 桶排序计数排序的改进。将数据分到有限数量的桶里，每个桶再分别排序。最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决于对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。12345678910111213141516171819202122232425#define DEFAULT_BUCKET_SIZE 5void BucketSort(int arr[], int n, int bucketSize) &#123; if(n == 0) return; int minValue = arr[0], maxValue = arr[0]; for(int i = 1; i &lt; n; i++) &#123; if(arr[i] &gt; maxValue) maxValue = arr[i]; if(arr[i] &lt; minValue) minValue = arr[i]; &#125; bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; // 默认每个桶的容量为5 int bucketNum = (maxValue-minValue)/bucketSize + 1;// 桶的数量 vector&lt; vector&lt;int&gt; &gt; buckets(bucketNum); for(int i=0; i&lt;n; i++) buckets[(arr[i]-minValue)/bucketSize].push_back(arr[i]); int sortIndex = 0; for(int i=0; i&lt;buckets.size(); i++) &#123; insertSort(buckets[i]); // 插入排序 for(int j=0; j&lt;buckets[i].size(); j++) arr[sortIndex++] = buckets[i][j]; &#125;&#125;¶ 10 基数排序基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。1234567891011121314151617181920212223242526272829// LSDvoid RedixSort(int arr[], int n, int maxDigit) &#123; int maxValue = arr[0], maxDigit = 0; for (int i=1; i&lt;n; i++) &#123; if (arr[i] &gt; maxValue) maxValue = arr[i]; &#125; while (maxValue) &#123; maxValue /= 10; maxDigit ++; &#125; int mod = 10; int dev = 1; vector&lt; vector&lt;int&gt; &gt; buckets(10); for(int i=0; i&lt;maxDigit; i++, dev*=10, mod*=10) &#123; for(int j=0; j&lt;n; j++) &#123; int bid = arr[j] % mod / dev;//取出对应数位作为桶编号 buckets[bid].push_back(arr[j]); &#125; int sortIndex = 0; for(int i=0; i&lt;buckets.size(); i++) &#123; for(int j=0; j&lt;buckets[i].size(); j++) arr[sortIndex++] = buckets[i][j]; buckets[i].clear(); &#125; &#125;&#125;¶ 11 Sortsort并不是简单的快速排序，它对普通的快速排序进行了优化，此外，它还结合了插入排序和推排序。系统会根据你的数据形式和数据量自动选择合适的排序方法，这并不是说它每次排序只选择一种方法，它是在一次完整排序中不同的情况选用不同方法，比如给一个数据量较大的数组排序，开始采用快速排序，分段递归，分段之后每一段的数据量达到一个较小值后它就不继续往下递归，而是选择插入排序，如果递归的太深，他会选择推排序。123456789#include &lt;algorithm&gt; // 头文件sort(a, a+n, cmp);// 自定义排序方式void cmp(int a, int b)&#123; return a &lt; b;&#125;¶ 总结稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。¶ 参考链接十大经典排序算法sort函数详解]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章加密TEST1]]></title>
    <url>%2F%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86TEST1%2F</url>
    <content type="text"><![CDATA[这只是一种障眼法文件/themes/next/layout/_partials/head.swig ，添加如下代码12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt;文章属性添加1password: # 你设定的密码​]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章加密TEST2]]></title>
    <url>%2F%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86TEST2%2F</url>
    <content type="text"><![CDATA[Please enter the password to read. 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]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub+Hexo搭建个人博客（五）Hexo博客优化和补充]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8GitHub-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%94%EF%BC%89Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%92%8C%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[¶ SEOSEO（Search Engine Optimization），汉译为搜索引擎优化。搜索引擎优化是一种利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的自然排名的方式。——百度百科¶ 1 站点地图站点地图是一个网站所有链接的容器。很多网站的连接层次比较深，爬虫很难抓取到，站点地图可以方便爬虫抓取网站页面，通过抓取网站页面，清晰了解网站的架构，网站地图一般存放在根目录下并命名sitemap，为爬虫指路，增加网站重要内容页面的收录。——百度百科安装插件12$ npm install hexo-generator-sitemap --save $ npm install hexo-generator-baidu-sitemap --save站点配置文件1234567# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://www.danboard.meroot: /permalink: :title/ # 链接后缀permalink_defaults: # 默认值 lang: enpermalink默认是:year/:month/:day/:title/ ，这样我们的文章生成的连接就会是sitname/year/month/day/title ，网站的连接层次比较深，很难被爬虫抓取，所以可以减少连接的层次验证执行修改后，可以在public目录中看到生成的两个文件sitemap.xml和baidusitemap.xml在浏览器中输入相应地址，如http://www.danboard.me/sitemap.xml来检查是否生成成功​¶ 2 谷歌收录效率非常高，但需要翻墙，也就是说你的博客只能在境外才能被搜索到首先检查站点是否被收录尝试使用Google Search Console登录/注册添加站点验证站点提交站点地图抓取 &gt; 站点地图验证收录​¶ 3 百度收录同样是，登录/注册 →\rightarrow→ 添加站点 →\rightarrow→ 验证站点 →\rightarrow→ 提交站点地图提交链接效率：主动推送 &gt; 自动推送 &gt; sitemap主动推送安装插件1$ npm install hexo-baidu-url-submit --save站点配置文件，添加12345baidu_url_submit: count: 1 # 提交最新的一个链接 host: www.danboard.me # 你的博客站点 token: your_token # 你的密钥 path: baidu_urls.txt # 新链接存放文档your_token:提交更新发布，使用命令hexo deploy时提交123456deploy:- type: git repo: - 你的github项目地址 branch: master # old- type: baidu_url_submitter # new注意：-属于一部分，注意格式对齐，否则会报错自动推送主题配置文件 ，字段baidu_push12# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: ture脚本位置位于themes/next/layout/_third-party/seo/baidu-push.swigsitemap与谷歌提交一致！！！还没有结束，百度收录不仅慢而且也比较麻烦了，因为github屏蔽了百度的爬虫，所以部署在github上的静态站点很难被百度搜索到。解决方法：将静态Pages托管到Coding上，重新解析一个新的二级域名，这样Coding和Github上的Pages就变成了两个独立的博客了。同一域名解析到不同的IP，保持之前的配置不改动，通过配置DNS，使国内的线路流量分配到Coding上，而其他线路分配到GitHub。这样，百度抓取就会跑到Coding上去。¶ 4 DNS流量分发Coding配置与GitHub是一致的，创建项目 →\rightarrow→ 开启静态Pages →\rightarrow→ 绑定域名站点配置文件，找到deploy：1234567deploy:- type: git repo: - 你的github项目地址 - 你的coding醒目地址 branch: master # old- type: baidu_url_submitter # newDNSPOD已被腾讯收购，可以登录DNSPOD / 腾讯云修改域名服务器，以GoDaddy域名为例先进入腾讯云控制台 →\rightarrow→ 域名管理，可以看到下方提示登录GoDaddy进入域名DNS管理，修改DNS，选择自定义返回腾讯云，进行域名解析​¶ 静态文件加载静态文件是一些js、css、html等文件，一般网站都会调用一大堆这些文件，如果调用的一些静态资源是通用的文件（第三方库），如jquery、fancybox，可以设定成合适的 CDN 地址，从而加速网站的运行。参考：NexT文档主题配置文档，字段vendors12345678910111213141516171819202122232425262728293031323334353637383940414243444546# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: //cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: //cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js fancybox_css: //cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: //cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: //cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: //cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: //cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: //cdn.jsdelivr.net/ua-parser.js/0.7.10/ua-parser.min.js # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: //maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css¶ Google引用Google被墙，所以有关谷歌类的引用都会导致引用失败，使网站加载变慢。例如：字体应用fonts.googleapis.com网上看到两种替代的：360：fonts.useso.com中科大： fonts.lug.ustc.edu.cn不过现在，问题来了，谷歌字体库解封了，360好像关了，中科大不稳定，所以呢？修改前还是要甄别一下站长工具如果需要修改，可以查看主题配置文件，字段font 以及文件themes/next/layout/_partials/head/external-fonts.swig¶ 博文压缩NexT主题在解析markdown文件时生成的代码会包含大量的空白，增加了文档的大小，影响网站的加载速度。安装插件1$ npm install --save hexo-all-minifierhexo-all-minifier文档主题配置文件，添加12345678910111213141516171819202122232425262728293031323334353637all_minifier: truejs_concator: enable: false bundle_path: '/js/bundle.js' front: false silent: falsehtml_minifier: # html压缩 enable: true ignore_error: false silent: false exclude: css_minifier: # css压缩 enable: true silent: false exclude: - '*.min.css'js_minifier: # js压缩 enable: true mangle: true silent: false output: compress: exclude: - '*.min.js'image_minifier: # 图片压缩 enable: true interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false silent: false​¶ 遇到问题¶ 1 注意备份之前遇到一个很严重的问题，hexo命令打错了本来是想安装某个插件，用了一下简写命令hexo i xx一不小心就点了回车，hexo i将文件都初始化了，打开链接一片空白自己还庆幸着懂得版本控制，可是一想，我一直用是hexo命令，只是生成了一些静态文件提交到github上，并没，有将整个源文件push上去，一下子头就大了最后，发现只有几个文件清空了，通过版本控制在提交到github的静态文件目录找到了对应的文件，及时修改回来。所以呢，这一波折，就是要告诉我，要时刻做好版本控制。GitHub上的私人仓库是要收费，而我们的源码中又包含了很多密钥，又不能放到公开仓库中。所以，要找替代品，国内有很多平台模仿GitHub的，例如Coding、码云之类，同样可以通过git控制，还提供免费的私人仓库。同时，该项目可以在其他电脑上clone，编辑并上传。¶ 2 大小写问题GitHub上好像对大小写不敏感，但是链接却对大小写敏感。我把一个标签or标题字母的大小写改了，结果就404回到GitHub上你可以发现仓库里文件名是没有改变的，所以呢，注意字母大小写问题，改动后的文件可以先不提交，GitHub自动把原来的文件删除后再提交，就不会出错了。¶ 3 手机适配电脑的屏幕比较大，同样的页面大小放到手机上坑定就不合适了。NexT主题已经初步适配了手机浏览器模式，但一些我们自定义的布局，还需要自己调整。例如，在前文讲过的GitHub边角问题，我们都可以在/themes/next/source/css/_custom/custom.styl文件中重新定义布局，考虑标签优先权问题，可以加上!important就有绝对优先权了。通过源代码，可以看到一种方便的手机浏览器适配方法，直接在标签内加上+mobile{}，例如我在一篇文章内添加了一个音乐播放器，电脑上宽度是合适的，手机上就爆了，修改如下：12345678.post .aplayer &#123; width: 520px; margin: 0 auto; +mobile() &#123; width: auto; margin: 0 auto; &#125; &#125;¶ 4 开发文档开发文档很重要，像Hexo文档提供了配置步骤、目录说明、主题插件等等，了解下开发文档，自定义修改的时候会更加方便。¶ 参考链接想让你的博客被更多的人在搜索引擎中搜到吗？Hexo插件之百度主动提交链接百度无法爬取Github Pages静态网站解决方案]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub+Hexo搭建个人博客（四）Hexo高阶之第三方插件]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8GitHub-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9B%9B%EF%BC%89Hexo%E9%AB%98%E9%98%B6%E4%B9%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Hexo 静态站点具有一定的局限性，需要借助第三方插件来扩展站点的功能。网上很多教程都是直接添加某些代码，但现在很多也已经merge到源码了，所以修改就比较方便了，true or false，开启或关闭功能，有些功能可能还需要在第三方服务上注册账号，获取API和APK 。利用Hexo搭建博客的人很多，但不都是千篇一律的，有些好的还是要借鉴的，更好的是能够有自己的风格~~~¶ RSS什么是RSS？简易信息聚合（也叫聚合内容）是一种RSS基于XML标准，在互联网上被广泛采用的内容包装和投递协议。RSS(Really Simple Syndication)是一种描述和同步网站内容的格式，是使用最广泛的XML应用。RSS搭建了信息迅速传播的一个技术平台，使得每个人都成为潜在的信息提供者。发布一个RSS文件后，这个RSS Feed中包含的信息就能直接被其他站点调用，而且由于这些数据都是标准的XML格式，所以也能在其他的终端和服务中使用，是一种描述和同步网站内容的格式。——百度百科¶ 1 生成RSS文件安装hexo-generator-feed插件1$ npm install --save hexo-generator-feed打开站点配置文件 ，字段Extensions，添加如下123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed打开主题配置文件 ，字段rss，添加如下1rss: /atom.xml配置完成，执行下列命令，可以看到/public文件夹中多了一个atom.xml文件1$ hexo g发布之后，在侧边栏会生成一个RSS图标¶ 2 RSS迁移安装hexo-migrator-rss插件1$ npm install --save hexo-migrator-rss执行下列命令，从 RSS 迁移所有文章。source 可以是文件路径或网址。1$ hexo migrate rss &lt;source&gt;¶ 评论系统NexT支持多款评论系统如果想要取消某个页面or文章的评论，在文章的属性中增加comments: false¶ 1 Valine一款基于Leancloud的快速、简洁且高效的无后端评论系统。支持匿名评论效果图：获取APP ID 和 APP KEY点击注册账号点击创建应用进入应用 &gt; 设置 &gt; 应用Key，可以看到APP ID 和 APP KEY配置打开主题配置文件 ，字段Valine12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true appid: # 填写获取的APP ID appkey: # 填写获取的APP KEY notify: true # 邮件提醒 verify: true # 验证码 placeholder: Just go go # 评论提示语 avatar: mm # 头像，具体看Valine官网 guest_info: nick,mail,link # 评论者相关属性 pageSize: 10 # 分页¶ 2 畅言需要实名登录，最不能接受的是还要绑定手机获取APP ID 和 APP KEY点击注册账号比较麻烦的是站点需要备案，没有备案只能使用15天有种投机取巧的方式，自行搜索进入 &gt; 后台总览 ，就可以看到了配置打开主题配置文件 ，字段changyan1234changyan: enable: true appid: # 填写获取的APP ID appkey: # 填写获取的APP KEY​¶ 访问统计页脚设计：/themes/next/layout/_partials/footer.swig文章设置：/themes/next/layout/_macro/post.swig¶ 1 不蒜子统计进入主题配置文件 ，字段busuanzi相关设置文件/themes/next/layout/_third-party/analytics/busuanzi-counter.swig123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site 整个网站访问用户量 site_uv: true site_uv_header: 本站访客数 site_uv_footer: 人次 # custom pv span for the whole site 整个网站访问总次数 site_pv: true site_pv_header: 本站总访问量 site_pv_footer: 次 # custom pv span for one page only 一篇文章的阅读次数 page_pv: true page_pv_header: 本文总阅读量 page_pv_footer: 次¶ 2 LeanCloud统计1234leancloud_visitors: # 文章阅读次数统计 enable: true appid: # 填写获取的APP ID appkey: # 填写获取的APP KEY¶ 3 字数统计安装插件1$ npm install --save hexo-wordcount配置123456post_wordcount: item_text: true wordcount: false # 文章字数 min2read: false # 阅读时长预计 totalcount: true # 全站字数 separated_meta: false # 分行¶ 博文置顶修改插件hero-generator-index ，文件node_modules/hexo-generator-index/lib/generator.js12345678910111213141516// var posts = locals.posts.sort(config.index_generator.order_by);// 改为var posts = locals.posts;posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 只有一篇文章top有定义，将排在最前面 return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排&#125;);文章属性添加top值，数值越大越靠前1top: # 数值¶ 文章搜索安装插件1$ npm install hexo-generator-searchdb --save站点配置文件 ，添加12345search: path: search.xml field: post format: html limit: 10000主题配置文件 ，字段local_search123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: ture # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1​¶ 添加挂件安装插件1$ npm install -save hexo-helper-live2d安装挂件预览1$ npm install --save live2d-widget-model-xxx # xxx为挂件名配置站点配置文件 ，添加123456789101112live2d: enable: true scriptFrom: local model: # 挂件模型 use: live2d-widget-model-hijiki display: # 位置 # position: right width: 80 height: 160 bottom: -120 mobile: # 手机显示 show: false​¶ 在线联系基于DaoVoice实现注册账号邀请码 832ef3b6获取API应用设置 &gt; 安装到网站配置文件/themes/next/layout/_partials/head.swig ，添加123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125;主题配置文件 ， 添加123# Online contact daovoice: truedaovoice_app_id: # 你获取的API效果 当有人发信息给你的时候，你可以通过DaoVoice在线交流，也可以关注DaoVoice小程序，绑定你的账号¶ 添加音乐¶ 网易云音乐外链​ 单曲复制代码，粘贴在你想要的位置，可以是文章 或者是 侧边栏歌单自己的歌单是没有生成外链。分享 →\rightarrow→ 动态 →\rightarrow→ 外链效果可以缩放¶ Aplayer引入js文件APlayer.min.js1&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.6.0/APlayer.min.js"&gt;&lt;/script&gt;位置themes/next/layout/_partials/head.swigMeting.min.js1&lt;script src="https://cdn.jsdelivr.net/npm/meting@1.0.1/dist/Meting.min.js"&gt;&lt;/script&gt;位置themes/next/layout/_partials/footer.swig添加音乐音乐平台1&lt;div class=&quot;aplayer&quot; data-id=&quot;&quot; data-server=&quot;&quot;&gt;&lt;/div&gt;参数解释：data-id: 歌曲/专辑/歌单 IDdata-server: 音乐平台，支持如下参数netease （网易云音乐）tencent （qq音乐）xiami （虾米音乐）kugou （酷狗音乐）baidu （百度音乐）data-type: 请求类型，支持如下参数song （单曲）album （专辑）playlist （歌单）search （搜索）​音乐外链（参数名可能与Aplayer中的不一样）1&lt;div class=&quot;aplayer&quot; data-title=&quot;&quot; data-author=&quot;&quot; data-url=&quot;&quot; data-pic=&quot;&quot; data-lrc=&quot;&quot;&gt;&lt;/div&gt;参数解释：data-title: 歌名data-author: 歌手data-url: 音乐链接data-pic: 音乐封面data-lrc: 歌词​其他参数data-mode: 播放模式random （随机）single （单曲）circulation （列表循环）order （列表）data-autoplay: 自动播放falsetrue​推荐Aplayer自定义比iframe还好，可以加载有版权问题的音乐，墙裂推荐！！！¶ (｡･∀･)ﾉﾞ嗨！一下这部分纯属玩乐，有点酷炫，我把它设置在了头像上，可以点击试一试音乐有点鬼畜，想不有什么好的，节奏可以配上该动画参考来自：Hexo high一下小功能资源js：http://oxv1k8kvi.bkt.clouddn.com/High.js可以自行下载来看一下里面的音乐地址和css可以替换一下mp3：http://oxv1k8kvi.bkt.clouddn.com/harlem-shake.mp3css：http://oxv1k8kvi.bkt.clouddn.com/harlem-shake-style.css配置文件/themes/next/layout/_partials/head.swig，添加1&lt;script type="text/javascript" src="http://oxv1k8kvi.bkt.clouddn.com/High.js"&gt;&lt;/script&gt;然后，在你想要点击实现high一下功能的地方，添加1&lt;a title=&quot;(｡･∀･)ﾉﾞ嗨！一下&quot; style=&quot;underline: none&quot; rel=&quot;alternate&quot; class=&quot;mw-harlem_shake_slow wobble shake&quot; href=&quot;javascript:shake()&quot;&gt; XXX &lt;/a&gt;​¶ 参考链接Next文档hexo的next主题个性化配置教程Valine – 一款极简的评论系统hexo-helper-live2dHexo音乐播放完美支持https和多平台AplayerHexo high一下小功能]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿楞的故事]]></title>
    <url>%2FDanboard%2F</url>
    <content type="text"><![CDATA[【转载】纸箱人阿楞我叫阿愣，是一个纸箱人，但又不仅仅是纸箱人。也许在你们人类的眼里，我充其量也只是个摆设品，是个玩具，抑或是一个废品。确实，我是从废旧的纸箱而来，但我不是个废品。因为我有一颗环保的心，也有一个充满爱的心。不要以为只有你们人类才有爱，在我们纸箱人的世界也有，但毕竟是两个不同的世界，爱也会不同。我们的爱似乎更简单，不会爱得泛滥，不会爱得势力，不会把爱随便洒在大马路上，让车辆辗，让行人踩……但你们的世界依然很伟大，尽管有无数的扭曲；而我们的世界是温馨的，因为思考的简单。一直以来我有个愿望，就是……偶然的一天，我来到了这美丽的郊外，看到满地的紫花，心情格外的好。突然看到了一株小小的绒球，我记得这是妈妈小时候给我讲过的故事中的蒲公英，看着它们，我发现世界原来如此可爱。我好想把它摘回去送给我最爱的人。天知道，对于我们纸箱人来说这有多困难啊！妈妈说过蒲公英会在角落静静的等待，等待某一阵风把它们小小的球吹散，吹向天空，吹向森林，吹向另一片陌生的土地……妈妈说蒲公英很勇敢，要我想它们学习，也要不怕风吹雨打，经得起磨练。蒲公英，你是勇敢的，你还要为自己的人生去飞翔，我没有权利阻止你，我也没有能力，因为你是无法停留的爱。我没有权利破坏那美丽的花的生命，就像人类没有权利破坏大自然一样。可是我真的很想送给我最爱的人一束花，哪怕是一朵。如果可以，我希望摘一朵快凋谢的花，让它在最后的时光看看我们纸箱人的世界，没有邪恶的恨，没有翻天覆地的斗争，尽管也有很多的不足……于是，我来到了杂草石堆里，选了最不起眼的一朵素色的花，我想即使是素色的也能配上我最爱的人，因为我最爱的人大多时候外表是素色的，可内心却是艳丽的。当我伸出双手，极力扑向它的时候，我发现自己是这么的无能为力，难道纸箱人的世界永远都与花无缘吗？而之前的那些是我在为自己开脱吗？在命运面前，我低下了头。虽然抬头需要很大的力气，可是低头却需要很大的勇气。我不相信，倔强地抬起头，望着蓝蓝的天，难道爱也有错吗？难道就因为我是纸箱人吗？第一次感觉这么地无助……踌躇了很久，不知不觉，下起了大雨。是上天在为我掉泪，还是在为我悲哀？站在雨中，我不想动，仍然倔强地抬起头，手指向远方……来吧，让那肆虐的大雨，把我浇醒！！！！我的骄傲就这样一点点地被熄灭，踌躇雨中,慢步前行。水滴不断顺着脸颊往下流，说不是雨水还是泪水……回到家就一头扎进了浴室，水流从喷头里冲出，肆无忌惮地喷在我的头上，身上……我想彻底地洗去身上的浮华，不求圣洁，只为安静。瘫软的我，乏力地躺在床上。我知道自己懦弱，对不起那个最爱我的人。我拼命地告诉自己，不要低头，不要难过，不要再去想一些遥远的事，可是脑子充满了灵幻的不安。就算再黑的夜，我也无法入睡。第二天一早，天还是蒙蒙亮的时候，我又出发了……我在寻找着我此前疑惑的答案。不知不觉，又来到了这片夹杂着朦胧美的大自然。看着那些，恍然隔世，偌大的森林，我只是其中小小的一员，小到微不足惜！在怎么走也走不出自己设定的圈套，明知是怎样的结局，却固执地不愿相信宿命的安排。以为以自己的力量可以改变一些什么，哪怕是一点点，殊不知这是不自量力。我是该继续往前走吗？还是退缩呢?正当犹豫的时候，一片树叶飘离了枝头，落在我的脚下。秋天来了？错，这还是盛夏的季节，却有树叶结束了自己的生命。抬头望了望那颗飘下落叶的大树，上面长满了茂盛的绿叶。生命如叶，突然间的心痛，让我相信生命是一种绝对的真挚。是时候该长大了，也该明白每一种生物体的本能是不同的，而所有的生命都是美丽的。生命不止，奋斗不息。又何必苦苦追寻不属于自己的世界呢？沿着山路不断往上爬，突然，身边出现了很多五彩的泡沫。看着它们身影斜斜地从我眼前消散，纸箱人的世界不是懦弱的世界，不是经不起虚晃的世界，不是充斥着无助与不安的世界！泡沫的色彩在阳光下，闪现出更多的光芒，无声地落满我的肩头！我最爱的人，你一定不会怪我摘不到一束花，因为那是大自然的力量，也不会责备我过去的自卑，因为心的距离才是最好的幸福。一阵风儿吹过，一朵蒲公英的绒花随风飘散，有的去流浪，有的去追逐梦想，有的去见识更大的世界……它们是勇敢的，无所畏惧的。我最爱的——妈妈，没能摘到花，却依然可以站在一起看蒲公英随风追逐，我想这已经很幸福了。用另一种方式也可以欣赏到大自然的美，用另一种方式也可以表达爱的关怀，用另一种方式可以体味不同的人生。有时候踮起脚尖，就是另一种人生，另一种境界……图片来源网络经过一些处理若侵权请告知]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub+Hexo搭建个人博客（三）Hexo个性化配置进阶]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8GitHub-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89Hexo%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[所谓的进阶，无非就是换个主题呀，添加一些小功能……看个人喜好吧！说到底，大部分都是参照网上的~~~¶ 主题安装Hexo官网提供了丰富的主题，挑选一款适合自己的，执行以下命令：basic1$ git clone [主题地址] [存放位置]例如我选择的主题是Next1$ git clone https://github.com/iissnan/hexo-theme-next themes/next完成之后，在themes目录下就会多了一个主题next的文件夹点击预览 themes进入站点配置文件 ，找到theme字段，修改为1theme: next进入主题配置文件 ，找到scheme字段，里面有next主题四种模板。12345# Schemesscheme: Muse# scheme: Mist# scheme: Pisces# scheme: Gemini首先使用命令，打开http://localhost:4000在本地预览，切换scheme刷新下页面看看效果1$ hexo s -g¶ Next主题¶ 主题目录.├── _config.yml├── languages├── layout├── scripts└── source具体解释¶ 基础配置进入站点配置文件 ，字段Site1234567# Sitetitle: Danboard # 网站标题subtitle: 踮起脚尖，另一种高度 # 副标题description: # 描述，显示在侧边栏author: Danboard # 作者language: zh-Hans # 语言timezone: Asia/Shanghai # 时间¶ 站点logo进入主题配置文件 ，字段favicon12345favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg图标推荐：Font Awesome阿里图标下载图标，指定大小，修改名称，存放在source/images/内¶ 菜单进入主题配置文件 ，字段menu默认支持Font Awesome图标，所以||后只要跟上图标名就ok，可以自行更换123456789menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbea选择自己想要的菜单项，取消注释新建一个about（关于我）页面1$ hexo new page &quot;about&quot;在hexo/source/下生成about/index.md ，编辑index.md文档新建一个tags（标签）页面1$ hexo new page &quot;tages&quot;在hexo/source/下生成tages/index.md ，修改如下1type: tages新建一个categories（分类）页面1$ hexo new page &quot;categories&quot;在hexo/source/下生成/index.md ，修改如下1type: categories新建一个腾讯公益404页面在hexo/source/下新建一个404.html的文件，内容如下：123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="返回主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;修改菜单1commonweal: /404.html || heartbea¶ 侧边栏进入主题配置文件 ，字段sidebar12345678sidebar: position: left # 靠左 #position: right # 靠右 #display: post # 默认，在文章页面（拥有目录列表）时显示 #display: always # 在所有页面中都显示 display: hide # 在所有页面中都隐藏（可以手动展开） #display: remove # 完全移除头像添加头像进入主题配置文件 ，字段avatar12avatar: /images/avatar.png # 放在source/images/# avatar: http://example.com/avatar.png # 网上链接 url圆形头像文件\themes\next\source\css\_common\components\sidebar\sidebar-author.styl ，添加代码：12345678.site-author-image &#123; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf;&#125;头像旋转同上，添加代码：1234567891011121314151617181920212223242526272829.site-author-image &#123; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123; /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;@-webkit-keyframes play &#123; // 同上&#125;@-moz-keyframes play &#123; // 同上&#125;社交链接进入主题配置文件 ，字段social12345678910111213141516social: GitHub: https://github.com/XXX || github #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: enable: true icons_only: false transition: false推荐阅读 or 友情链接进入主题配置文件 ，字段Blogrolls1234567# Blog rollslinks_icon: linklinks_title: 友情链接# links_layout: block # 块级 分行显示links_layout: inline # 内联 同行显示links: # 添加友链 SYSU: http://www.sysu.edu.cn/¶ GitHub边角效果：文件themes/next/layout/_layout.swig ，复制代码放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下，修改href为自己的github地址因为我是把github的logo放在了左上角，在手机上查看就会发现logo与菜单重和了如果想要修改边角位置，可以在文件themes/next/source/css/_custom/custom.styl 中进行更改12345678svg &#123; float: left; transform: scale(-1, 1); +mobile() &#123; float: right; transform: scale(1, 1); &#125; &#125;GitHub cornerfork me on GitHub​¶ 动画效果背景动画进入主题配置文件 ，字段canvas_nest12345# 4种，开启true，关闭falsecanvas_nest: falsethree_waves: falsecanvas_lines: truecanvas_sphere: false进度条进入主题配置文件 ，字段Progress1234# Progress bar in the top during page loading.pace: truepace_theme: pace-theme-flash¶ 文章编辑首页预览多篇文章，通过阅读全文打开&lt;!--more--&gt;截断 推荐在想要显示在首页的文字下方添加标签&lt;!--more--&gt;文章属性description123456---title: 文章标题date: 发布时间tages: 文章标签description: 摘要，显示在首页---自动显示进入主题配置文件 ，字段auto_excerpt123auto_excerpt: enable: true length: 150 # 截取长度为150个字符文章背景添加边框阴影，突出文章，打开文件themes/next/source/css/_custom/custom.styl ，该文件可以让自定义一些布局，通过浏览器的开发者工具找到对应标签，就可以进行设置了。12345678.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; background-color: #fff; -webkit-box-shadow: 0 0 10px rgba(202, 203, 204, .5); -moz-box-shadow: 0 0 10px rgba(202, 203, 204, .5);&#125;文章分割线文章添加边框阴影后，分割线就显得有点多余，在custom.styl文件中添加1234.posts-expand .post-eof &#123; margin: 0px; background-color: rgba(255, 255, 255, 0);&#125;代码高亮进入主题配置文件 ，字段highlight123# Available value:# normal | night | night eighties | night blue | night brighthighlight_theme: normal文章打赏进入主题配置文件 ，字段reward，将支付宝or微信收款二维码图片保存到文件夹/themes/next/source/images/下12345# Reward#reward_comment: Donate comment herewechatpay: /images/wechatpay.jpgalipay: /images/alipay.jpg# bitcoin: /images/bitcoin.png文章分享Next这里提供了三种：jiathis、百度、豆瓣，效果都差不多自定义文件都在themes/next/layout/_partials/share/jiathis分享1jiathis: true百度分享1234baidushare: type: button# Available value: # 两种样式 下方 | 侧边# button | slide豆瓣（自己试了，不能用）1duoshuo_share: true文章加密这只是一种障眼法文件/themes/next/layout/_partials/head.swig ，添加如下代码12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt;文章属性添加1password: # 你设定的密码​¶ 参考链接Next文档hexo的next主题个性化配置教程]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[端口占用的解决方法]]></title>
    <url>%2F%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[有时候明明打开了服务器，端口也配置好了，就是不能访问，这时候可能要考虑是否是端口被占用了，端口被占用有时候是没有提示的。解决的话，有两种方法：第一种，改端口；第二种，禁用占用该端口的软件。下面只介绍后者：打开命令管理器，快捷键win+R查找占用端口的程序对应的PID1netstat -ano|findstr [端口号]稍微接解释一下netstat，详细资料可以输入 netstat ? 或是找度娘-a 显示所有连接和侦听端口。-n 以数字形式显示地址和端口号。-o 显示拥有的与每个连接关联的进程 ID。（合并指令 -ano 就是列出所有端口的情况了）findstr 在端口使用情况中找到我们需要的端口根据PID查找端口占用的程序1tasklist|findstr [PID]tasklist：显示在本地或远程机器上当前运行的进程列表解除占用打开任务管理器，选择详细信息 ，点击程序，再点右下方的结束任务就ok了。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>port</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub+Hexo搭建个人博客（二）配置Hexo博客基础框架]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8GitHub-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E9%85%8D%E7%BD%AEHexo%E5%8D%9A%E5%AE%A2%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。—来自“Hexo文档”¶ 配置环境Node.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。什么是npm？允许用户从NPM服务器下载别人编写的第三方包到本地使用。允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。总而言之，就是要使用npm来安装Hexo​安装Hexo打开Git Bash 或是 命令管理器，执行以下命令就可以了，这样本地就有了hexo的包路径一般在C:/Users/用户名/AppData/Roaming/npm/hexo1$ npm install hexo-cli -g¶ 部署博客hexo实例创建一个文件夹，存放blog的配置文件执行hexo命令1$npm init初始完成，可以看到文件夹中多了以下文件：node_modules：依赖包（一些黑操作，官网有相应的包，也可以自己编写）scaffolds：文章模板（post默认、page、draft）source：存放文章（/_post/xx.md）themes：主题（默认landscape，有点丑，hexo官网预览，下载自己心仪的主题）_config.yml：整个博客的配置（themes中也有一个同名文件，为了区分前者称为站点配置文件 ，后者称为主题配置文件）package.json：应用程序的信息部署到github打开站点配置文件 ：_config.yml，Ctrl+F找到deploy，进行如下配置，最后保存1234deploy: type: git repo: 你的github项目地址 branch: master你的github项目地址执行下面命令123$ hexo clean$ hexo generate$ hexo serverhexo文件解释与命令，请参照Hexo文档进行本地预览打开浏览器输入：localhost:4000hexo server默认打开的是4000端口如果不能打开，有可能是4000端口被其他程序给占用了第一种方法，请看端口被占用的解决方法第二种方法，切换端口1$ hexo server -p [端口号]​上传到GitHub服务器如果预览没问题的话，就可以上传到服务器了123$ hexo clean$ hexo generate$ hexo deploy​ 发布文章1$ hexo new [layout] &lt;title&gt;layout：文件夹scaffolds中的文章模板（post默认、page、draft），也可以自定义title：文章标题最后还是一样预览再发布到github服务器就ok啦~​¶ 参考链接Hexo文档使用hexo+github搭建免费个人博客详细教程]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub+Hexo搭建个人博客（一）GitHub新建一个blog项目]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8GitHub-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89GitHub%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AAblog%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[一个博客就像自己的一片小天地搭建一个属于自己的博客，记录、整理、分享自己的所见所闻、所学所感。网上有许多搭建博客的平台，但个人只了解了github，比较方便，提供域名和服务器，由hexo提供个性模板，如果有自己的域名，还可以解析到博客链接上，更加自主个性。¶ GitHub服务器拥有一个github账号点击注册点击新建一个项目**注意：**Repository name为自己github账号的名字(例如我的账号YH-Chen) + .github.io，博客地址就是该名字yh-chen.github.io如果是自定义的名称(例如Danboard)，博客的地址就变成yh-chen.github.io/Danboard。设置博客进入项目，选择settings1） 如果Repository name直接是xxx.github.io，直接拉到最后，可以看到GitHub Pages，它已经自动生成博客链接了，打开链接只显示标题xxx.github.io。如果你拥有自己的个性域名，先解析到你的博客地址，再在Custom domain里填写你的域名，就可以使用自己的域名登录自己的博客了。点击choose a theme可以选择github默认的博客主题选择之后，它会打开创建项目时保存的README.md文件，编辑的内容为markdown语言基础，以后的博客也是用markdown来编辑。直接点击commit changes就可以了。2） 如果Repository name是一般的名称，同样在设置中拉到GitHub Pages，将Source改为master branch就可以，其他的就跟上面一样了。¶ 编辑博客git工具Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。—百度百科点击下载github是一个面向开源软件项目的托管平台。虽然github上提供了文件编辑和上传的功能，但使用起来并不方便，所以将项目clone到本地，在本地进行编辑，再通过git（也可以使用githubDestop桌面客户端）上传到平台，这里就需要了解一下git的基础命令和配置了。clone博客项目到本地点击clone or download，复制链接打开git bash，输入命令1$ git clone https://github.com/XXX/XXX.github.io.git编辑简单的博客1234$ echo &quot;Hello World!&quot; &gt; index.html$ git add index.html$ git commit -m &quot;Init commit&quot;$ git push origin master打开链接之后，发现只有Hello World！了。没有结束！！！现在只是完成初步工作，拥有了一个博客，在本地也备份了一份文件，但博客还是空空的，什么格式都没有，下一步就是要利用Hexo弄出一个博客框架。¶ 参考链接GitHub Pages三分钟在GitHub上搭建个人博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
